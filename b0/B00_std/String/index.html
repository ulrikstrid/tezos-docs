<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>String (b0.B00_std.String)</title><link rel="stylesheet" href="../../../odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0-beta2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">b0</a> &#x00BB; <a href="../index.html">B00_std</a> &#x00BB; String</nav><header class="odoc-preamble"><h1>Module <code><span>B00_std.String</span></code></h1><p>Strings.</p></header><nav class="odoc-toc"><ul><li><a href="#stdlib_string">Stdlib <code>String</code></a></li><li><a href="#strings">Strings</a></li><li><a href="#preds">Predicates</a></li><li><a href="#subs">Extracting substrings</a></li><li><a href="#break">Breaking</a><ul><li><a href="#break_mag">Breaking with magnitudes</a></li><li><a href="#break_pred">Breaking with predicates</a></li><li><a href="#break_sep">Breaking with separators</a></li></ul></li><li><a href="#fmt">Formatting</a></li><li><a href="#unique">Uniqueness</a></li><li><a href="#suggesting">Suggesting</a></li><li><a href="#escunesc">(Un)escaping bytes</a></li><li><a href="#ascii">US-ASCII strings</a></li><li><a href="#version">Version strings</a></li><li><a href="#setmap">Sets and maps</a></li><li><a href="#var_subst">Variable substitution</a></li></ul></nav><div class="odoc-content"><h2 id="stdlib_string"><a href="#stdlib_string" class="anchor"></a>Stdlib <code>String</code></h2><div class="odoc-include"><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../../ocaml/Stdlib/String/index.html">Stdlib.String</a></span></code></span></summary><div class="odoc-spec"><div class="spec external" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span>string <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the length (number of characters) of the given string.</p></div></div><div class="odoc-spec"><div class="spec external" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span>string <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p><code>String.get s n</code> returns the character at index <code>n</code> in string <code>s</code>. You can also write <code>s.[n]</code> instead of <code>String.get s n</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n</code> not a valid index in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec external" id="val-set" class="anchored"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>String.set s n c</code> modifies byte sequence <code>s</code> in place, replacing the byte at index <code>n</code> with <code>c</code>. You can also write <code>s.[n] &lt;- c</code> instead of <code>String.set s n c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p><dl><dt>deprecated</dt><dd><p>This is a deprecated alias of <code>Bytes</code>.set.<code> </code></p></dd></dl></div></div><div class="odoc-spec"><div class="spec external" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>String.create n</code> returns a fresh byte sequence of length <code>n</code>. The sequence is uninitialized and contains arbitrary bytes.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><code>Sys</code>.max_string_length.</p><dl><dt>deprecated</dt><dd><p>This is a deprecated alias of <code>Bytes</code>.create.<code> </code></p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>String.make n c</code> returns a fresh string of length <code>n</code>, filled with the character <code>c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><code>Sys</code>.max_string_length.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span>int <span>&#45;&gt;</span></span> <span><span>(<span>int <span>&#45;&gt;</span></span> char)</span> <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>String.init n f</code> returns a string of length <code>n</code>, with character <code>i</code> initialized to the result of <code>f i</code> (called in increasing index order).</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><code>Sys</code>.max_string_length.</p><dl><dt>since</dt><dd>4.02.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-copy" class="anchored"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the given string.</p><dl><dt>deprecated</dt><dd><p>Because strings are immutable, it doesn't make much sense to make identical copies of them.</p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-sub" class="anchored"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span>string <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>String.sub s start len</code> returns a fresh string of length <code>len</code>, containing the substring of <code>s</code> that starts at position <code>start</code> and has length <code>len</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid substring of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fill" class="anchored"><a href="#val-fill" class="anchor"></a><code><span><span class="keyword">val</span> fill : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>String.fill s start len c</code> modifies byte sequence <code>s</code> in place, replacing <code>len</code> bytes with <code>c</code>, starting at <code>start</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p><dl><dt>deprecated</dt><dd><p>This is a deprecated alias of <code>Bytes</code>.fill.<code> </code></p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-blit" class="anchored"><a href="#val-blit" class="anchor"></a><code><span><span class="keyword">val</span> blit : <span>string <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <code>Bytes</code>.blit_string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span>string <span>&#45;&gt;</span></span> <span><span>string list</span> <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>String.concat sep sl</code> concatenates the list of strings <code>sl</code>, inserting the separator string <code>sep</code> between each.</p><p>Raise <code>Invalid_argument</code> if the result is longer than <code>Sys</code>.max_string_length bytes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span>char <span>&#45;&gt;</span></span> unit)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>String.iter f s</code> applies function <code>f</code> in turn to all the characters of <code>s</code>. It is equivalent to <code>f s.[0]; f s.[1]; ...; f s.[String.length s - 1]; ()</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span><span>(<span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> unit)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <a href="#val-iter"><code>String.iter</code></a>, but the function is applied to the index of the element as first argument (counting from 0), and the character itself as second argument.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span>char <span>&#45;&gt;</span></span> char)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>String.map f s</code> applies function <code>f</code> in turn to all the characters of <code>s</code> (in increasing index order) and stores the results in a new string that is returned.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>(<span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> char)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>String.mapi f s</code> calls <code>f</code> with each character of <code>s</code> and its index (in increasing index order) and stores the results in a new string that is returned.</p><dl><dt>since</dt><dd>4.02.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-trim" class="anchored"><a href="#val-trim" class="anchor"></a><code><span><span class="keyword">val</span> trim : <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, without leading and trailing whitespace. The characters regarded as whitespace are: <code>' '</code>, <code>'\012'</code>, <code>'\n'</code>, <code>'\r'</code>, and <code>'\t'</code>. If there is neither leading nor trailing whitespace character in the argument, return the original string itself, not a copy.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-escaped" class="anchored"><a href="#val-escaped" class="anchor"></a><code><span><span class="keyword">val</span> escaped : <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml. All characters outside the ASCII printable range (32..126) are escaped, as well as backslash and double-quote.</p><p>If there is no special character in the argument that needs escaping, return the original string itself, not a copy.</p><p>Raise <code>Invalid_argument</code> if the result is longer than <code>Sys</code>.max_string_length bytes.</p><p>The function <code>Scanf</code>.unescaped is a left inverse of <code>escaped</code>, i.e. <code>Scanf.unescaped (escaped s) = s</code> for any string <code>s</code> (unless <code>escape s</code> fails).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-index" class="anchored"><a href="#val-index" class="anchor"></a><code><span><span class="keyword">val</span> index : <span>string <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>String.index s c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code>.</p><p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-index_opt" class="anchored"><a href="#val-index_opt" class="anchor"></a><code><span><span class="keyword">val</span> index_opt : <span>string <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>String.index_opt s c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code>, or <code>None</code> if <code>c</code> does not occur in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex" class="anchored"><a href="#val-rindex" class="anchor"></a><code><span><span class="keyword">val</span> rindex : <span>string <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>String.rindex s c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code>.</p><p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_opt" class="anchored"><a href="#val-rindex_opt" class="anchor"></a><code><span><span class="keyword">val</span> rindex_opt : <span>string <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>String.rindex_opt s c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code>, or <code>None</code> if <code>c</code> does not occur in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-index_from" class="anchored"><a href="#val-index_from" class="anchor"></a><code><span><span class="keyword">val</span> index_from : <span>string <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>String.index_from s i c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code> after position <code>i</code>. <code>String.index s c</code> is equivalent to <code>String.index_from s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-index_from_opt" class="anchored"><a href="#val-index_from_opt" class="anchor"></a><code><span><span class="keyword">val</span> index_from_opt : <span>string <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>String.index_from_opt s i c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code> after position <code>i</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p><p><code>String.index_opt s c</code> is equivalent to <code>String.index_from_opt s 0 c</code>. Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_from" class="anchored"><a href="#val-rindex_from" class="anchor"></a><code><span><span class="keyword">val</span> rindex_from : <span>string <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>String.rindex_from s i c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code> before position <code>i+1</code>. <code>String.rindex s c</code> is equivalent to <code>String.rindex_from s (String.length s - 1) c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_from_opt" class="anchored"><a href="#val-rindex_from_opt" class="anchor"></a><code><span><span class="keyword">val</span> rindex_from_opt : <span>string <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>String.rindex_from_opt s i c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code> before position <code>i+1</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p><p><code>String.rindex_opt s c</code> is equivalent to <code>String.rindex_from_opt s (String.length s - 1) c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-contains" class="anchored"><a href="#val-contains" class="anchor"></a><code><span><span class="keyword">val</span> contains : <span>string <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>String.contains s c</code> tests if character <code>c</code> appears in the string <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-contains_from" class="anchored"><a href="#val-contains_from" class="anchor"></a><code><span><span class="keyword">val</span> contains_from : <span>string <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>String.contains_from s start c</code> tests if character <code>c</code> appears in <code>s</code> after position <code>start</code>. <code>String.contains s c</code> is equivalent to <code>String.contains_from s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> is not a valid position in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rcontains_from" class="anchored"><a href="#val-rcontains_from" class="anchor"></a><code><span><span class="keyword">val</span> rcontains_from : <span>string <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>String.rcontains_from s stop c</code> tests if character <code>c</code> appears in <code>s</code> before position <code>stop+1</code>.</p><p>Raise <code>Invalid_argument</code> if <code>stop &lt; 0</code> or <code>stop+1</code> is not a valid position in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uppercase" class="anchored"><a href="#val-uppercase" class="anchor"></a><code><span><span class="keyword">val</span> uppercase : <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-lowercase" class="anchored"><a href="#val-lowercase" class="anchor"></a><code><span><span class="keyword">val</span> lowercase : <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-capitalize" class="anchored"><a href="#val-capitalize" class="anchor"></a><code><span><span class="keyword">val</span> capitalize : <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with the first character set to uppercase, using the ISO Latin-1 (8859-1) character set..</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-uncapitalize" class="anchored"><a href="#val-uncapitalize" class="anchor"></a><code><span><span class="keyword">val</span> uncapitalize : <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with the first character set to lowercase, using the ISO Latin-1 (8859-1) character set..</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-uppercase_ascii" class="anchored"><a href="#val-uppercase_ascii" class="anchor"></a><code><span><span class="keyword">val</span> uppercase_ascii : <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with all lowercase letters translated to uppercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.03.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-lowercase_ascii" class="anchored"><a href="#val-lowercase_ascii" class="anchor"></a><code><span><span class="keyword">val</span> lowercase_ascii : <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with all uppercase letters translated to lowercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.03.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-capitalize_ascii" class="anchored"><a href="#val-capitalize_ascii" class="anchor"></a><code><span><span class="keyword">val</span> capitalize_ascii : <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with the first character set to uppercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.03.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-uncapitalize_ascii" class="anchored"><a href="#val-uncapitalize_ascii" class="anchor"></a><code><span><span class="keyword">val</span> uncapitalize_ascii : <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with the first character set to lowercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.03.0</dd></dl></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = string</span></code></div><div class="spec-doc"><p>An alias for the type of strings.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span>&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The comparison function for strings, with the same specification as <a href="../../../ocaml/Stdlib/index.html#val-compare"><code>Stdlib.compare</code></a>. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>String</code> to be passed as argument to the functors <code>Set</code>.Make and <code>Map</code>.Make.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span>&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>The equal function for strings.</p><dl><dt>since</dt><dd>4.03.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-split_on_char" class="anchored"><a href="#val-split_on_char" class="anchor"></a><code><span><span class="keyword">val</span> split_on_char : <span>char <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>String.split_on_char sep s</code> returns the list of all (possibly empty) substrings of <code>s</code> that are delimited by the <code>sep</code> character.</p><p>The function's output is specified by the following invariants:</p><ul><li>The list is not empty.</li><li>Concatenating its elements using <code>sep</code> as a separator returns a string equal to the input (<code>String.concat (String.make 1 sep)
      (String.split_on_char sep s) = s</code>).</li><li>No string in the result contains the <code>sep</code> character.</li></ul><dl><dt>since</dt><dd>4.04.0</dd></dl></div></div><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2><div class="odoc-spec"><div class="spec value" id="val-to_seq" class="anchored"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><a href="#type-t">t</a> <span>&#45;&gt;</span></span> <span>char <a href="../../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the string, in increasing index order. Modifications of the string during iteration will be reflected in the iterator.</p><dl><dt>since</dt><dd>4.07</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-to_seqi" class="anchored"><a href="#val-to_seqi" class="anchor"></a><code><span><span class="keyword">val</span> to_seqi : <span><a href="#type-t">t</a> <span>&#45;&gt;</span></span> <span><span>(int * char)</span> <a href="../../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the string, in increasing order, yielding indices along chars</p><dl><dt>since</dt><dd>4.07</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq" class="anchored"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span>char <a href="../../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span> <span>&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a string from the generator</p><dl><dt>since</dt><dd>4.07</dd></dl></div></div></details></div></div></div><h2 id="strings"><a href="#strings" class="anchor"></a>Strings</h2><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : string</span></code></div><div class="spec-doc"><p><code>empty</code> is <code>&quot;&quot;</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-head" class="anchored"><a href="#val-head" class="anchor"></a><code><span><span class="keyword">val</span> head : <span>string <span>&#45;&gt;</span></span> <span>char option</span></span></code></div><div class="spec-doc"><p><code>head s</code> if <code>Some s.[0]</code> if <code>s &lt;&gt; &quot;&quot;</code> and <code>None</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_char" class="anchored"><a href="#val-of_char" class="anchor"></a><code><span><span class="keyword">val</span> of_char : <span>char <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>of_char c</code> is <code>c</code> as a string.</p></div></div><h2 id="preds"><a href="#preds" class="anchor"></a>Predicates</h2><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span>string <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty s</code> is <code>equal empty s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_prefix" class="anchored"><a href="#val-is_prefix" class="anchor"></a><code><span><span class="keyword">val</span> is_prefix : <span>affix:string <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_prefix ~affix s</code> is <code>true</code> iff <code>affix.[i] = s.[i]</code> for all indices <code>i</code> of <code>affix</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_infix" class="anchored"><a href="#val-is_infix" class="anchor"></a><code><span><span class="keyword">val</span> is_infix : <span>affix:string <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_infix ~affix s</code> is <code>true</code> iff there exists an index <code>j</code> such that for all indices <code>i</code> of <code>affix</code>, <code>affix.[i] = s.[j+ 1]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_suffix" class="anchored"><a href="#val-is_suffix" class="anchor"></a><code><span><span class="keyword">val</span> is_suffix : <span>affix:string <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_suffix ~affix s</code> is true iff <code>affix.[i] = s.[m - i]</code> for all indices <code>i</code> of <code>affix</code> and with <code>m = String.length s - 1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>(<span>char <span>&#45;&gt;</span></span> bool)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>for_all p s</code> is <code>true</code> iff for all indices <code>i</code> of <code>s</code>, <code>p s.[i]
      = true</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span>(<span>char <span>&#45;&gt;</span></span> bool)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>exists p s</code> is <code>true</code> iff there exists an index <code>i</code> of <code>s</code> with <code>p s.[i] = true</code>.</p></div></div><h2 id="subs"><a href="#subs" class="anchor"></a>Extracting substrings</h2><div class="odoc-spec"><div class="spec value" id="val-subrange" class="anchored"><a href="#val-subrange" class="anchor"></a><code><span><span class="keyword">val</span> subrange : <span>?&#8288;first:int <span>&#45;&gt;</span></span> <span>?&#8288;last:int <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>subrange ~first ~last s</code> are the consecutive bytes of <code>s</code> whose indices exist in the range [<code>first</code>;<code>last</code>].</p><p><code>first</code> defaults to <code>0</code> and last to <code>String.length s - 1</code>.</p><p>Note that both <code>first</code> and <code>last</code> can be any integer. If <code>first &gt; last</code> the interval is empty and the empty string is returned.</p></div></div><h2 id="break"><a href="#break" class="anchor"></a>Breaking</h2><h3 id="break_mag"><a href="#break_mag" class="anchor"></a>Breaking with magnitudes</h3><div class="odoc-spec"><div class="spec value" id="val-take_left" class="anchored"><a href="#val-take_left" class="anchor"></a><code><span><span class="keyword">val</span> take_left : <span>int <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>take_left n s</code> are the first <code>n</code> bytes of <code>s</code>. This is <code>s</code> if <code>n &gt;= length s</code> and <code>&quot;&quot;</code> if <code>n &lt;= 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_right" class="anchored"><a href="#val-take_right" class="anchor"></a><code><span><span class="keyword">val</span> take_right : <span>int <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>take_right n s</code> are the last <code>n</code> bytes of <code>s</code>. This is <code>s</code> if <code>n &gt;= length s</code> and <code>&quot;&quot;</code> if <code>n &lt;= 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_left" class="anchored"><a href="#val-drop_left" class="anchor"></a><code><span><span class="keyword">val</span> drop_left : <span>int <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>drop_left n s</code> is <code>s</code> without the first <code>n</code> bytes of <code>s</code>. This is <code>&quot;&quot;</code> if <code>n &gt;= length s</code> and <code>s</code> if <code>n &lt;= 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_right" class="anchored"><a href="#val-drop_right" class="anchor"></a><code><span><span class="keyword">val</span> drop_right : <span>int <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>drop_right n s</code> is <code>s</code> without the last <code>n</code> bytes of <code>s</code>. This is <code>&quot;&quot;</code> if <code>n &gt;= length s</code> and <code>s</code> if <code>n &lt;= 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-break_left" class="anchored"><a href="#val-break_left" class="anchor"></a><code><span><span class="keyword">val</span> break_left : <span>int <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string * string</span></code></div><div class="spec-doc"><p><code>break_left n v</code> is <code>(take_left n v, drop_left n v)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-break_right" class="anchored"><a href="#val-break_right" class="anchor"></a><code><span><span class="keyword">val</span> break_right : <span>int <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string * string</span></code></div><div class="spec-doc"><p><code>break_right n v</code> is <code>(drop_left n v, take_right n v)</code>.</p></div></div><h3 id="break_pred"><a href="#break_pred" class="anchor"></a>Breaking with predicates</h3><div class="odoc-spec"><div class="spec value" id="val-keep_left" class="anchored"><a href="#val-keep_left" class="anchor"></a><code><span><span class="keyword">val</span> keep_left : <span><span>(<span>char <span>&#45;&gt;</span></span> bool)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>keep_left sat s</code> are the first consecutive <code>sat</code> statisfying bytes of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-keep_right" class="anchored"><a href="#val-keep_right" class="anchor"></a><code><span><span class="keyword">val</span> keep_right : <span><span>(<span>char <span>&#45;&gt;</span></span> bool)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>keep_right sat s</code> are the last consecutive <code>sat</code> satisfying bytes of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lose_left" class="anchored"><a href="#val-lose_left" class="anchor"></a><code><span><span class="keyword">val</span> lose_left : <span><span>(<span>char <span>&#45;&gt;</span></span> bool)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>lose_left sat s</code> is <code>s</code> without the first consecutive <code>sat</code> satisfying bytes of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lose_right" class="anchored"><a href="#val-lose_right" class="anchor"></a><code><span><span class="keyword">val</span> lose_right : <span><span>(<span>char <span>&#45;&gt;</span></span> bool)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>lose_right sat s</code> is <code>s</code> without the last consecutive <code>sat</code> satisfying bytes of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-span_left" class="anchored"><a href="#val-span_left" class="anchor"></a><code><span><span class="keyword">val</span> span_left : <span><span>(<span>char <span>&#45;&gt;</span></span> bool)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string * string</span></code></div><div class="spec-doc"><p><code>span_left sat s</code> is <code>(keep_left sat s, lose_left sat s)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-span_right" class="anchored"><a href="#val-span_right" class="anchor"></a><code><span><span class="keyword">val</span> span_right : <span><span>(<span>char <span>&#45;&gt;</span></span> bool)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string * string</span></code></div><div class="spec-doc"><p><code>span_right sat s</code> is <code>(lose_right sat s, keep_right sat s)</code>.</p></div></div><h3 id="break_sep"><a href="#break_sep" class="anchor"></a>Breaking with separators</h3><div class="odoc-spec"><div class="spec value" id="val-cut_left" class="anchored"><a href="#val-cut_left" class="anchor"></a><code><span><span class="keyword">val</span> cut_left : <span>sep:string <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span><span>(string * string)</span> option</span></span></code></div><div class="spec-doc"><p><code>cut ~sep s</code> is either the pair <code>Some (l,r)</code> of the two (possibly empty) substrings of <code>s</code> that are delimited by the first match of the separator character <code>sep</code> or <code>None</code> if <code>sep</code> can't be matched in <code>s</code>. Matching starts from the left of <code>s</code>.</p><p>The invariant <code>l ^ sep ^ r = s</code> holds.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>sep</code> is the empty string.</p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-cut_right" class="anchored"><a href="#val-cut_right" class="anchor"></a><code><span><span class="keyword">val</span> cut_right : <span>sep:string <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span><span>(string * string)</span> option</span></span></code></div><div class="spec-doc"><p><code>cut_right ~sep s</code> is like <a href="#val-cut_left"><code>cut_left</code></a> but matching starts on the right of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cuts_left" class="anchored"><a href="#val-cuts_left" class="anchor"></a><code><span><span class="keyword">val</span> cuts_left : <span>?&#8288;drop_empty:bool <span>&#45;&gt;</span></span> <span>sep:string <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>cuts_left sep s</code> is the list of all substrings of <code>s</code> that are delimited by matches of the non empty separator string <code>sep</code>. Empty substrings are omitted in the list if <code>drop_empty</code> is <code>true</code> (defaults to <code>false</code>).</p><p>Matching separators in <code>s</code> starts from the left of <code>s</code> (<code>rev</code> is <code>false</code>, default) or the end (<code>rev</code> is <code>true</code>). Once one is found, the separator is skipped and matching starts again, that is separator matches can't overlap. If there is no separator match in <code>s</code>, the list <code>[s]</code> is returned.</p><p>The following invariants hold:</p><ul><li><code>concat ~sep (cuts ~drop_empty:false ~sep s) = s</code></li><li><code>cuts ~drop_empty:false ~sep s &lt;&gt; []</code></li></ul><dl><dt>raises Invalid_argument</dt><dd><p>if <code>sep</code> is the empty string.</p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-cuts_right" class="anchored"><a href="#val-cuts_right" class="anchor"></a><code><span><span class="keyword">val</span> cuts_right : <span>?&#8288;drop_empty:bool <span>&#45;&gt;</span></span> <span>sep:string <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>cuts_right sep s</code> is like <a href="#val-cuts_left"><code>cuts_left</code></a> but matching starts on the right of <code>s</code>.</p></div></div><h2 id="fmt"><a href="#fmt" class="anchor"></a>Formatting</h2><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span>string <a href="../Fmt/index.html#type-t">Fmt.t</a></span></span></code></div><div class="spec-doc"><p><code>pp ppf s</code> prints <code>s</code>'s bytes on <code>ppf</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_dump" class="anchored"><a href="#val-pp_dump" class="anchor"></a><code><span><span class="keyword">val</span> pp_dump : <span>string <a href="../Fmt/index.html#type-t">Fmt.t</a></span></span></code></div><div class="spec-doc"><p><code>pp_dump ppf s</code> prints <code>s</code> as a syntactically valid OCaml string on <code>ppf</code>.</p></div></div><h2 id="unique"><a href="#unique" class="anchor"></a>Uniqueness</h2><div class="odoc-spec"><div class="spec value" id="val-uniquify" class="anchored"><a href="#val-uniquify" class="anchor"></a><code><span><span class="keyword">val</span> uniquify : <span><span>string list</span> <span>&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>uniquify ss</code> is <code>ss</code> without duplicates, the list order is preserved.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unique" class="anchored"><a href="#val-unique" class="anchor"></a><code><span><span class="keyword">val</span> unique : <span>exists:<span>(<span>string <span>&#45;&gt;</span></span> bool)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span><span>(string,Â string)</span> <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></span></code></div><div class="spec-doc"><p><code>unique ~exist n</code> is <code>n</code> if <code>exists n</code> is <code>false</code> or <code>r = strf
      &quot;%s~%d&quot; n d</code> with <code>d</code> the smallest integer in [<code>1</code>;<code>1e9</code>] such that <code>exists r</code> is <code>false</code> or an error if there is no such string.</p></div></div><h2 id="suggesting"><a href="#suggesting" class="anchor"></a>Suggesting</h2><div class="odoc-spec"><div class="spec value" id="val-edit_distance" class="anchored"><a href="#val-edit_distance" class="anchor"></a><code><span><span class="keyword">val</span> edit_distance : <span>string <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>edit_distance s0 s1</code> is the number of single character edits (insertion, deletion, substitution) that are needed to change <code>s0</code> into <code>s1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-suggest" class="anchored"><a href="#val-suggest" class="anchor"></a><code><span><span class="keyword">val</span> suggest : <span>?&#8288;dist:int <span>&#45;&gt;</span></span> <span><span>string list</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>suggest ~dist candidates s</code> are the elements of <code>candidates</code> whose <a href="#val-edit_distance">edit distance</a> is the smallest to <code>s</code> and at most at a distance of <code>dist</code> of <code>s</code> (defaults to <code>2</code>). If multiple results are returned the order of <code>candidates</code> is preserved.</p></div></div><h2 id="escunesc"><a href="#escunesc" class="anchor"></a>(Un)escaping bytes</h2><p>The following functions can only (un)escape a single byte. See also <a href="#escunesc">these functions</a> to convert a string to printable US-ASCII characters.</p><div class="odoc-spec"><div class="spec value" id="val-byte_escaper" class="anchored"><a href="#val-byte_escaper" class="anchor"></a><code><span><span class="keyword">val</span> byte_escaper : <span><span>(<span>char <span>&#45;&gt;</span></span> int)</span> <span>&#45;&gt;</span></span> <span><span>(<span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> int)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>byte_escaper char_len set_char</code> is a byte escaper such that:</p><ul><li><code>char_len c</code> is the length of the unescaped byte <code>c</code> in the escaped form. If <code>1</code> is returned then <code>c</code> is assumed to be unchanged use <a href="#val-byte_replacer"><code>byte_replacer</code></a> if that does not hold</li><li><code>set_char b i c</code> sets an unescaped byte <code>c</code> to its escaped form at index <code>i</code> in <code>b</code> and returns the next writable index. <code>set_char</code> is called regardless if <code>c</code> needs to be escaped or not in the latter case <b>you must</b> write <code>c</code> (use <a href="#val-byte_replacer"><code>byte_replacer</code></a> if that is not the case). No bounds check need to be performed on <code>i</code> or the returned value.</li></ul><p>For any <code>b</code>, <code>c</code> and <code>i</code> the invariant <code>i + char_len c = set_char b i c</code> must hold.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-byte_replacer" class="anchored"><a href="#val-byte_replacer" class="anchor"></a><code><span><span class="keyword">val</span> byte_replacer : <span><span>(<span>char <span>&#45;&gt;</span></span> int)</span> <span>&#45;&gt;</span></span> <span><span>(<span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> int)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>byte_replacer char_len set_char</code> is like <a href="#val-byte_escaper"><code>byte_escaper</code></a> but a byte can be substituted by another one by <code>set_char</code>.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Illegal_escape" class="anchored"><a href="#exception-Illegal_escape" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Illegal_escape</span> <span class="keyword">of</span> int</span></code></div><div class="spec-doc"><p>See <code>unescaper</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-byte_unescaper" class="anchored"><a href="#val-byte_unescaper" class="anchor"></a><code><span><span class="keyword">val</span> byte_unescaper : <span><span>(<span>string <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int)</span> <span>&#45;&gt;</span></span> <span><span>(<span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span><span>(string,Â int)</span> <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></span></code></div><div class="spec-doc"><p><code>byte_unescaper char_len_at set_char</code> is a byte unescaper such that:</p><ul><li><code>char_len_at s i</code> is the length of an escaped byte at index <code>i</code> of <code>s</code>. If <code>1</code> is returned then the byte is assumed to be unchanged by the unescape, use <code>byte_unreplace</code> if that does not hold.</li><li><code>set_char b k s i</code> sets at index <code>k</code> in <code>b</code> the unescaped byte read at index <code>i</code> in <code>s</code> and returns the next readable index in <code>s</code>. <code>set_char</code> is called regardless of wheter the byte at <code>i</code> must be unescaped or not in the latter case <b>you must</b> write s.<code>i</code> only (use <a href="#val-byte_unreplacer"><code>byte_unreplacer</code></a> if that is not the case). No bounds check need to be performed on <code>k</code>, <code>i</code> or the returned value.</li></ul><p>For any <code>b</code>, <code>s</code>, <code>k</code> and <code>i</code> the invariant <code>i + char_len_at s i
      = set_char b k s i</code> must hold.</p><p>Both <code>char_len_at</code> and <code>set_char</code> may raise <code>Illegal_escape i</code> if the given index <code>i</code> has an illegal or truncated escape. The unescaper turns this exception into <code>Error i</code> if that happens.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-byte_unreplacer" class="anchored"><a href="#val-byte_unreplacer" class="anchor"></a><code><span><span class="keyword">val</span> byte_unreplacer : <span><span>(<span>string <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int)</span> <span>&#45;&gt;</span></span> <span><span>(<span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int)</span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span><span>(string,Â int)</span> <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></span></code></div><div class="spec-doc"><p><code>byte_unreplacer char_len_at set_char</code> is like <code>byte_unscaper</code> except <code>set_char</code> can set a different byte whenever <code>char_len_at</code> returns <code>1</code>.</p></div></div><h2 id="ascii"><a href="#ascii" class="anchor"></a>US-ASCII strings</h2><div class="odoc-spec"><div class="spec module" id="module-Ascii" class="anchored"><a href="#module-Ascii" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Ascii/index.html">Ascii</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>US-ASCII string support.</p></div></div><h2 id="version"><a href="#version" class="anchor"></a>Version strings</h2><div class="odoc-spec"><div class="spec value" id="val-to_version" class="anchored"><a href="#val-to_version" class="anchor"></a><code><span><span class="keyword">val</span> to_version : <span>string <span>&#45;&gt;</span></span> <span><span>(int * int * int * <span>string option</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>to_version</code> parses version strings of the form:</p><pre><code>&quot;[v|V]major.minor[.patchlevel][+additional-info]&quot;</code></pre><p>into <code>(major, minor, patch, additional_info)</code> tuples. If no <code>patchlevel</code> is found <code>0</code> is used.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_initial_v" class="anchored"><a href="#val-drop_initial_v" class="anchor"></a><code><span><span class="keyword">val</span> drop_initial_v : <span>string <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>drop_initial_v s</code> drops a leading <code>'v'</code> or <code>'V'</code> from <code>s</code>.</p></div></div><h2 id="setmap"><a href="#setmap" class="anchor"></a>Sets and maps</h2><div class="odoc-spec"><div class="spec module" id="module-Set" class="anchored"><a href="#module-Set" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Set/index.html">Set</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>String sets.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Map" class="anchored"><a href="#module-Map" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Map/index.html">Map</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>String maps.</p></div></div><h2 id="var_subst"><a href="#var_subst" class="anchor"></a>Variable substitution</h2><div class="odoc-spec"><div class="spec value" id="val-subst_pct_vars" class="anchored"><a href="#val-subst_pct_vars" class="anchor"></a><code><span><span class="keyword">val</span> subst_pct_vars : <span>?&#8288;buf:<a href="../../../ocaml/Stdlib/Buffer/index.html#type-t">Stdlib.Buffer.t</a> <span>&#45;&gt;</span></span> <span><span>string <a href="Map/index.html#type-t">Map.t</a></span> <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p><code>subst_pct_vars ~buf vars s</code> substitutes in <code>s</code> strings of the form <code>%%VAR%%</code> by the value of <code>&quot;VAR&quot;</code> in <code>vars</code> (if any). <code>None</code> is returned if no substitution was performed.</p></div></div></div></body></html>