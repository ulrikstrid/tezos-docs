<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tezos_store__Block_store (tezos-store.Tezos_store__Block_store)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0-beta2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">tezos-store</a> &#x00BB; Tezos_store__Block_store</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_store__Block_store</span></code></h1><p>Persistent and cached generic block store</p><p>The store instantiate a cemented block store and multiple floating block stores. The floating stores serve as buffers until enough blocks have arrived. Then it performs a &quot;cementing&quot; (also called a &quot;merge&quot;). Under normal circumstances, there are two different kinds (<code>Floating_block_store</code>.floating_kind) of floating stores instances: a <code>RO</code>(read-only) and a <code>RW</code>(read-write). Newly arrived blocks are <b>always</b> pushed in the <code>RW</code> instance. The block lookup is first tried in <code>RW</code>, then <code>RO</code> and finally in the cement blocks.</p><p>This store also instantiates a LRU block cache to reduce the number of I/O operations. This cache is updated whenever a block is read or stored.</p><p>When a merge occurs, the <code>RW</code> instance is promoted as another <code>RO'</code> and a new <code>RW'</code> instance replaces it. This allows retrieving the new cycle to be cemented from <code>RO</code> and <code>RO'</code> (former <code>RW</code>) <b>asynchronously</b> and thus allowing new blocks to be stored in the newly instantiated <code>RW</code> store without pausing. This asynchronous merging thread, while retrieving the cycle to cement, also combines <code>RO</code> and <code>RO'</code> into a <b>new</b> <code>RO''</code> without the cemented cycle. When the merging thread is done, the former <code>RO</code> and <code>RO'</code> instances are deleted from the disk and the new <code>RO''</code> replaces them. A merging thread has to wait for the previous one to finish.</p><p>Retrieving the new cycle from <code>RO</code> and <code>RO'</code> from blocks <code>B_start</code> and <code>B_end</code> means that we must retrieve the set of blocks between them but also trim potential branches that have roots in this set. To achieve that, we iterate over <code>RO</code> and <code>RO'</code> <b>linearly</b>. This means that <b>every block's predecessor in floating stores must be previously known</b>. Either we previously encountered it in the same floating store file, either in <code>RO</code> if the block is in <code>RO'</code> or in the cemented store (see invariants below). This invariant is required to ensure minimal memory usage. The iterations done to retrieve the cycle and merge the floating stores works similarly to a <i>stop and copy</i> GC algorithm. It works as follows:</p><ul><li>We retrieve the blocks from <code>B_end</code> to <code>B_start</code> by sequentially reading predecessors.</li></ul><ul><li>We instantiate a set of encountered block hashes with <code>B_end</code>'s hash as initial value.</li></ul><ul><li>We iterate sequentially over <code>RO</code> and <code>RO'</code> blocks and copy them only if their predecessors is present in the visited set, adding their hash in the process.</li></ul><p>The result is a correct, in order and trimmed new <code>RO</code> floating store. A visual example of merging is given below.</p><p>The merging thread will also trigger a garbage-collection of the cemented block store w.r.t. the given history mode.</p><h2 id="invariants"><a href="#invariants" class="anchor"></a>Invariants</h2><p>This store is expected to respect the following invariants:</p><ul><li>If no merging thread is pending, two floating stores are present: a <code>RO</code> and a <code>RW</code>.</li></ul><ul><li>If a merging thread is pending, there are three floating stores present: a <code>RO</code>, a <code>RO'</code> and a <code>RW</code>.</li></ul><ul><li>Blocks may be stored twice in <b>floating stores</b> but only when a merging occurs (as <code>RO''</code> is a subset of <code>RO</code>+<code>RO'</code>). However, blocks can be present in both the cemented and the floating store (after importing a storage snapshot as the floating block store consist in a checkpoint associated with its `max_op_ttl` blocks which were already cemented).</li></ul><ul><li>For every stored block in floating stores, its predecessor is either already stored in the same floating store file, in a previous floating store file or in the cemented store.</li></ul><ul><li>A merging thread does not start until the previous one has completed.</li></ul></header><div class="odoc-content"></div></body></html>