<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Json_encoding (json-data-encoding.Json_encoding)</title><link rel="stylesheet" href="../../odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0-beta2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">json-data-encoding</a> &#x00BB; Json_encoding</nav><header class="odoc-preamble"><h1>Module <code><span>Json_encoding</span></code></h1><p>JSON structure description using dependently typed combinators.</p></header><nav class="odoc-toc"><ul><li><a href="#dependent-types-describing-json-document-structures">Dependent types describing JSON document structures</a></li><li><a href="#constructors-and-destructors-for-json_repr.ezjsonm">Constructors and destructors for Json_repr.ezjsonm</a></li><li><a href="#json-type-combinators-for-simple-immediates">JSON type combinators for simple immediates</a></li><li><a href="#json-type-combinators-for-objects">JSON type combinators for objects</a></li><li><a href="#json-type-combinators-for-arrays">JSON type combinators for arrays</a></li><li><a href="#json-type-combinators-for-unions">JSON type combinators for unions</a></li><li><a href="#json-generic-type-combinators">JSON generic type combinators</a></li><li><a href="#exporting-encodings-as-json-schemas">Exporting <code>encoding</code>s as JSON schemas</a></li><li><a href="#errors">Errors</a></li><li><a href="#advanced-interface-for-using-a-custom-json-representation">Advanced interface for using a custom JSON representation</a></li></ul></nav><div class="odoc-content"><h3 id="dependent-types-describing-json-document-structures"><a href="#dependent-types-describing-json-document-structures" class="anchor"></a>Dependent types describing JSON document structures</h3><div class="odoc-spec"><div class="spec type" id="type-encoding" class="anchored"><a href="#type-encoding" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a encoding</span></span></code></div><div class="spec-doc"><p>An encoding between an OCaml data type (the parameter) and a JSON representation. To be built using the predefined combinators provided by this module.</p><p>For instance, here is an encoding, of type <code>(int * string)
    encoding</code>, mapping values of type <code>int * string</code> to JSON objects with a field <code>code</code> of whose value is a number and a field <code>message</code> whose value is a string.</p><p><code>let enc = obj2 (req &quot;code&quot; int) (req &quot;message&quot; string)</code></p><p>This encoding serves three purposes:</p><p>1. Output an OCaml value of type <code>'a</code> to an intermediate JSON representation using <a href="#val-construct"><code>construct</code></a>. To be printed to actual JSON using an external library. 2. Input a JSON intermediate structure (already parsed with an external library) to produce an OCaml value of type <code>'a</code>. 3. Describe this encoding in JSON-schema format for inter-operability: you describe the encoding of your internal types, and obtain machine-readable descriptions of the formats as a byproduct. Specific documentation combinators are provided for that purpose.</p><p>By default, this library provides functions that work on the <a href="../Json_repr/index.html#type-ezjsonm"><code>Json_repr.ezjsonm</code></a> data type, compatible with <code>Ezjsonm</code>.value. However, encodings are not tied with this representation. See functor <a href="Make/index.html"><code>Make</code></a> and module <a href="../Json_repr/index.html"><code>Json_repr</code></a> for using another format.</p></div></div><h3 id="constructors-and-destructors-for-json_repr.ezjsonm"><a href="#constructors-and-destructors-for-json_repr.ezjsonm" class="anchor"></a>Constructors and destructors for Json_repr.ezjsonm</h3><p>see <a href="../Json_repr/index.html#type-ezjsonm"><code>Json_repr.ezjsonm</code></a></p><div class="odoc-spec"><div class="spec value" id="val-construct" class="anchored"><a href="#val-construct" class="anchor"></a><code><span><span class="keyword">val</span> construct : <span>?&#8288;include_default_fields:<span>[ `Always <span>| `Auto</span> <span>| `Never</span> ]</span> <span>&#45;&gt;</span></span>
<span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span class="type-var">'t</span> <span>&#45;&gt;</span></span> <a href="../Json_repr/index.html#type-ezjsonm">Json_repr.ezjsonm</a></span></code></div><div class="spec-doc"><p>Builds a json value from an OCaml value and an encoding.</p><p>The optional argument <code>?include_default_fields</code> allows to systematically manage the behaviour of <code>?construct</code> argument of <code>dft</code> fields.</p><p>This function works with JSON data represented in the <a href="../Json_repr/index.html#type-ezjsonm"><code>Json_repr.ezjsonm</code></a> format. See functor <a href="Make/index.html"><code>Make</code></a> for using another representation.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-jsonm_lexeme" class="anchored"><a href="#type-jsonm_lexeme" class="anchor"></a><code><span><span class="keyword">type</span> jsonm_lexeme</span><span> = </span><span>[ </span></code><table><tr id="type-jsonm_lexeme.Null" class="anchored"><td class="def constructor"><a href="#type-jsonm_lexeme.Null" class="anchor"></a><code><span>| </span></code><code><span>`Null</span></code></td></tr><tr id="type-jsonm_lexeme.Bool" class="anchored"><td class="def constructor"><a href="#type-jsonm_lexeme.Bool" class="anchor"></a><code><span>| </span></code><code><span>`Bool <span class="keyword">of</span> bool</span></code></td></tr><tr id="type-jsonm_lexeme.String" class="anchored"><td class="def constructor"><a href="#type-jsonm_lexeme.String" class="anchor"></a><code><span>| </span></code><code><span>`String <span class="keyword">of</span> string</span></code></td></tr><tr id="type-jsonm_lexeme.Float" class="anchored"><td class="def constructor"><a href="#type-jsonm_lexeme.Float" class="anchor"></a><code><span>| </span></code><code><span>`Float <span class="keyword">of</span> float</span></code></td></tr><tr id="type-jsonm_lexeme.Name" class="anchored"><td class="def constructor"><a href="#type-jsonm_lexeme.Name" class="anchor"></a><code><span>| </span></code><code><span>`Name <span class="keyword">of</span> string</span></code></td></tr><tr id="type-jsonm_lexeme.As" class="anchored"><td class="def constructor"><a href="#type-jsonm_lexeme.As" class="anchor"></a><code><span>| </span></code><code><span>`As</span></code></td></tr><tr id="type-jsonm_lexeme.Ae" class="anchored"><td class="def constructor"><a href="#type-jsonm_lexeme.Ae" class="anchor"></a><code><span>| </span></code><code><span>`Ae</span></code></td></tr><tr id="type-jsonm_lexeme.Os" class="anchored"><td class="def constructor"><a href="#type-jsonm_lexeme.Os" class="anchor"></a><code><span>| </span></code><code><span>`Os</span></code></td></tr><tr id="type-jsonm_lexeme.Oe" class="anchored"><td class="def constructor"><a href="#type-jsonm_lexeme.Oe" class="anchor"></a><code><span>| </span></code><code><span>`Oe</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type of json lexeme. This type is compatible with <code>Jsonm.lexeme</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-construct_seq" class="anchored"><a href="#val-construct_seq" class="anchor"></a><code><span><span class="keyword">val</span> construct_seq : <span>?&#8288;include_default_fields:<span>[ `Always <span>| `Auto</span> <span>| `Never</span> ]</span> <span>&#45;&gt;</span></span>
<span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span class="type-var">'t</span> <span>&#45;&gt;</span></span> <span><a href="#type-jsonm_lexeme">jsonm_lexeme</a> <a href="../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span></span></code></div><div class="spec-doc"><p>Builds a lazy Seq representation of the OCaml value.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-jsonm_lexeme_seq_of_ezjson" class="anchored"><a href="#val-jsonm_lexeme_seq_of_ezjson" class="anchor"></a><code><span><span class="keyword">val</span> jsonm_lexeme_seq_of_ezjson : <span><a href="../Json_repr/index.html#type-ezjsonm">Json_repr.ezjsonm</a> <span>&#45;&gt;</span></span> <span><a href="#type-jsonm_lexeme">jsonm_lexeme</a> <a href="../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span></span></code></div><div class="spec-doc"><p>Converts json AST (<code>ezjsonm</code>) into a sequence representation</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destruct" class="anchored"><a href="#val-destruct" class="anchor"></a><code><span><span class="keyword">val</span> destruct : <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><a href="../Json_repr/index.html#type-ezjsonm">Json_repr.ezjsonm</a> <span>&#45;&gt;</span></span> <span class="type-var">'t</span></span></code></div><div class="spec-doc"><p>Reads an OCaml value from a JSON value and an encoding. May raise <code>Cannot_destruct</code>.</p><p>This function works with JSON data represented in the <a href="../Json_repr/index.html#type-ezjsonm"><code>Json_repr.ezjsonm</code></a> format. See functor <a href="Make/index.html"><code>Make</code></a> for using another representation.</p></div></div><h3 id="json-type-combinators-for-simple-immediates"><a href="#json-type-combinators-for-simple-immediates" class="anchor"></a>JSON type combinators for simple immediates</h3><div class="odoc-spec"><div class="spec value" id="val-unit" class="anchored"><a href="#val-unit" class="anchor"></a><code><span><span class="keyword">val</span> unit : <span>unit <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml unit by any (ignored) JSON.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-null" class="anchored"><a href="#val-null" class="anchor"></a><code><span><span class="keyword">val</span> null : <span>unit <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml unit by a JSON null.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span>unit <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml unit by an empty JSON object.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int" class="anchored"><a href="#val-int" class="anchor"></a><code><span><span class="keyword">val</span> int : <span>int <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml int by a JSON number.</p><p>When destructing, the JSON number cannot have a fractional part, and must be between <code>-2^30</code> and <code>2^30-1</code> (these bounds are chosen to be compatible with both 32-bit and 64bit native OCaml compilers as well as JavaScript). When constructing, the value coming from the OCaml world is assumed to be valid, otherwise an <code>Invalid_argument</code> will be raised (can only happen on 64-bit systems).</p><p>Use <a href="#val-int32"><code>int32</code></a> or <a href="#val-int53"><code>int53</code></a> for a greater range. Use <a href="#val-ranged_int"><code>ranged_int</code></a> to restrict to an interval.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int32" class="anchored"><a href="#val-int32" class="anchor"></a><code><span><span class="keyword">val</span> int32 : <span>int32 <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml int32 by a JSON number.</p><p>Must be a floating point without fractional part and between <code>-2^31</code> and <code>2^31-1</code> when destructing. Never fails when constructing, as all 32-bit integers are included in JSON numbers.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int53" class="anchored"><a href="#val-int53" class="anchor"></a><code><span><span class="keyword">val</span> int53 : <span>int64 <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of a JSON-representable OCaml int64 by a JSON number.</p><p>Restricted to the <code>-2^53</code> to <code>2^53</code> range, as this is the limit of representable integers in JSON numbers. Must be a floating point without fractional part and in this range when destructing. When constructing, the value coming from the OCaml world is assumed to be in this range, otherwise an <code>Invalid_argument</code> will be raised.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ranged_int" class="anchored"><a href="#val-ranged_int" class="anchor"></a><code><span><span class="keyword">val</span> ranged_int : <span>minimum:int <span>&#45;&gt;</span></span> <span>maximum:int <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span>int <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml int by a JSON number restricted to a specific range.</p><p>The bounds must be between <code>-2^30</code> and <code>2^30-1</code>.</p><p>The inclusive bounds are checked when destructing. When constructing, the value coming from the OCaml world is assumed to be within the bounds, otherwise an <code>Invalid_argument</code> will be raised. The string parameter is a name used to tweak the error messages.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ranged_int32" class="anchored"><a href="#val-ranged_int32" class="anchor"></a><code><span><span class="keyword">val</span> ranged_int32 : <span>minimum:int32 <span>&#45;&gt;</span></span> <span>maximum:int32 <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span>int32 <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml int32 by a JSON number restricted to a specific range.</p><p>The bounds must be between <code>-2^31</code> and <code>2^31-1</code>.</p><p>The inclusive bounds are checked when destructing. When constructing, the value coming from the OCaml world is assumed to be within the bounds, otherwise an <code>Invalid_argument</code> will be raised. The string parameter is a name used to tweak the error messages.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ranged_int53" class="anchored"><a href="#val-ranged_int53" class="anchor"></a><code><span><span class="keyword">val</span> ranged_int53 : <span>minimum:int64 <span>&#45;&gt;</span></span> <span>maximum:int64 <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span>int64 <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml int64 by a JSON number restricted to a specific range.</p><p>The bounds must be between <code>-2^53</code> and <code>2^53</code>.</p><p>The inclusive bounds are checked when destructing. When constructing, the value coming from the OCaml world is assumed to be within the bounds, otherwise an <code>Invalid_argument</code> will be raised. The string parameter is a name used to tweak the error messages.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bool" class="anchored"><a href="#val-bool" class="anchor"></a><code><span><span class="keyword">val</span> bool : <span>bool <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml boolean by a JSON one.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string" class="anchored"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml string by a JSON one.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_enum" class="anchored"><a href="#val-string_enum" class="anchor"></a><code><span><span class="keyword">val</span> string_enum : <span><span><span>(string * <span class="type-var">'a</span>)</span> list</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of a closed set of OCaml values by JSON strings.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-constant" class="anchored"><a href="#val-constant" class="anchor"></a><code><span><span class="keyword">val</span> constant : <span>string <span>&#45;&gt;</span></span> <span>unit <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of a constant string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bytes" class="anchored"><a href="#val-bytes" class="anchor"></a><code><span><span class="keyword">val</span> bytes : <span>bytes <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml mutable string by a JSON string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-float" class="anchored"><a href="#val-float" class="anchor"></a><code><span><span class="keyword">val</span> float : <span>float <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml float by a JSON number.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ranged_float" class="anchored"><a href="#val-ranged_float" class="anchor"></a><code><span><span class="keyword">val</span> ranged_float : <span>minimum:float <span>&#45;&gt;</span></span> <span>maximum:float <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span>float <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml float by a JSON number with range constraints</p></div></div><div class="odoc-spec"><div class="spec value" id="val-option" class="anchored"><a href="#val-option" class="anchor"></a><code><span><span class="keyword">val</span> option : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml option by a nullable JSON value. Raises <code>Invalid_argument</code> when nesting options â€“ i.e., when building <code>'a option
    option encoding</code>. Also raises <code>Invalid_argument</code> when used on the encoding of <code>null</code>.</p></div></div><h3 id="json-type-combinators-for-objects"><a href="#json-type-combinators-for-objects" class="anchor"></a>JSON type combinators for objects</h3><div class="odoc-spec"><div class="spec type" id="type-field" class="anchored"><a href="#type-field" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a field</span></span></code></div><div class="spec-doc"><p>A first class handle to a JSON field.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-req" class="anchored"><a href="#val-req" class="anchor"></a><code><span><span class="keyword">val</span> req : <span>?&#8288;title:string <span>&#45;&gt;</span></span> <span>?&#8288;description:string <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span class="type-var">'t</span> <a href="#type-field">field</a></span></span></code></div><div class="spec-doc"><p>A required field of a given its type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-opt" class="anchored"><a href="#val-opt" class="anchor"></a><code><span><span class="keyword">val</span> opt : <span>?&#8288;title:string <span>&#45;&gt;</span></span> <span>?&#8288;description:string <span>&#45;&gt;</span></span> <span>string <span>&#45;&gt;</span></span> <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'t</span> option</span> <a href="#type-field">field</a></span></span></code></div><div class="spec-doc"><p>An optional field of a given type, using an OCaml <code>option</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dft" class="anchored"><a href="#val-dft" class="anchor"></a><code><span><span class="keyword">val</span> dft : <span>?&#8288;title:string <span>&#45;&gt;</span></span> <span>?&#8288;description:string <span>&#45;&gt;</span></span> <span>?&#8288;construct:bool <span>&#45;&gt;</span></span>
<span>string <span>&#45;&gt;</span></span> <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span class="type-var">'t</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'t</span> <a href="#type-field">field</a></span></span></code></div><div class="spec-doc"><p>An optional field of a given type. The field is omitted when equal to the default value except when <code>construct</code> is <code>true</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-obj1" class="anchored"><a href="#val-obj1" class="anchor"></a><code><span><span class="keyword">val</span> obj1 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml value by a singleton object.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-obj2" class="anchored"><a href="#val-obj2" class="anchor"></a><code><span><span class="keyword">val</span> obj2 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml pair by a JSON object with two fields.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-obj3" class="anchored"><a href="#val-obj3" class="anchor"></a><code><span><span class="keyword">val</span> obj3 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml triple by a JSON object with three fields.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-obj4" class="anchored"><a href="#val-obj4" class="anchor"></a><code><span><span class="keyword">val</span> obj4 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml quadruple by a JSON object with four fields.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-obj5" class="anchored"><a href="#val-obj5" class="anchor"></a><code><span><span class="keyword">val</span> obj5 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml quintuple by a JSON object with five fields.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-obj6" class="anchored"><a href="#val-obj6" class="anchor"></a><code><span><span class="keyword">val</span> obj6 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml sextuple by a JSON object with six fields.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-obj7" class="anchored"><a href="#val-obj7" class="anchor"></a><code><span><span class="keyword">val</span> obj7 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f7</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml septuple by a JSON object with seven fields.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-obj8" class="anchored"><a href="#val-obj8" class="anchor"></a><code><span><span class="keyword">val</span> obj8 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f7</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f8</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml octuple by a JSON object with eight fields.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-obj9" class="anchored"><a href="#val-obj9" class="anchor"></a><code><span><span class="keyword">val</span> obj9 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f7</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f8</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f9</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span> * <span class="type-var">'f9</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml nonuple by a JSON object with nine fields.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-obj10" class="anchored"><a href="#val-obj10" class="anchor"></a><code><span><span class="keyword">val</span> obj10 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f7</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f8</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f9</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f10</span> <a href="#type-field">field</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span> * <span class="type-var">'f9</span> * <span class="type-var">'f10</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml decuple by a JSON object with ten fields.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge_objs" class="anchored"><a href="#val-merge_objs" class="anchor"></a><code><span><span class="keyword">val</span> merge_objs : <span><span><span class="type-var">'o1</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'o2</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'o1</span> * <span class="type-var">'o2</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Merge two object <code>encoding</code>s. For describing heavyweight objects with a lot of fields. The ocaml type is a pair of tuples, but the JSON object is flat. Both arguments must be object encodings, otherwise a future <a href="#val-construct"><code>construct</code></a>, <a href="#val-destruct"><code>destruct</code></a> or <a href="#val-schema"><code>schema</code></a> will fail with <code>Invalid_argument</code>.</p></div></div><h3 id="json-type-combinators-for-arrays"><a href="#json-type-combinators-for-arrays" class="anchor"></a>JSON type combinators for arrays</h3><div class="odoc-spec"><div class="spec value" id="val-array" class="anchored"><a href="#val-array" class="anchor"></a><code><span><span class="keyword">val</span> array : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml array by a JSON one.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-list" class="anchored"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml list by a JSON one.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assoc" class="anchored"><a href="#val-assoc" class="anchor"></a><code><span><span class="keyword">val</span> assoc : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span>(string * <span class="type-var">'a</span>)</span> list</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml associative list by a JSON object.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tup1" class="anchored"><a href="#val-tup1" class="anchor"></a><code><span><span class="keyword">val</span> tup1 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml value by a singleton array.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tup2" class="anchored"><a href="#val-tup2" class="anchor"></a><code><span><span class="keyword">val</span> tup2 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml pair by a JSON array with two cells.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tup3" class="anchored"><a href="#val-tup3" class="anchor"></a><code><span><span class="keyword">val</span> tup3 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml triple by a JSON array with three cells.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tup4" class="anchored"><a href="#val-tup4" class="anchor"></a><code><span><span class="keyword">val</span> tup4 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml quadruple by a JSON array with four cells.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tup5" class="anchored"><a href="#val-tup5" class="anchor"></a><code><span><span class="keyword">val</span> tup5 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml quintuple by a JSON array with five cells.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tup6" class="anchored"><a href="#val-tup6" class="anchor"></a><code><span><span class="keyword">val</span> tup6 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml sextuple by a JSON array with six cells.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tup7" class="anchored"><a href="#val-tup7" class="anchor"></a><code><span><span class="keyword">val</span> tup7 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f7</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml septuple by a JSON array with seven cells.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tup8" class="anchored"><a href="#val-tup8" class="anchor"></a><code><span><span class="keyword">val</span> tup8 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f7</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f8</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml octuple by a JSON array with eight cells.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tup9" class="anchored"><a href="#val-tup9" class="anchor"></a><code><span><span class="keyword">val</span> tup9 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f7</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f8</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f9</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span> * <span class="type-var">'f9</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml nonuple by a JSON array with nine cells.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tup10" class="anchored"><a href="#val-tup10" class="anchor"></a><code><span><span class="keyword">val</span> tup10 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f7</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f8</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f9</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'f10</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span> * <span class="type-var">'f9</span> * <span class="type-var">'f10</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml decuple by a JSON array with ten cells.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge_tups" class="anchored"><a href="#val-merge_tups" class="anchor"></a><code><span><span class="keyword">val</span> merge_tups : <span><span><span class="type-var">'a1</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'a2</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span>(<span class="type-var">'a1</span> * <span class="type-var">'a2</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Merge two tuple <code>encoding</code>s. For describing heavyweight arrays with a lot of cells. The ocaml type is a pair of tuples, but the JSON array is flat, with the elements of the first tuple before the ones of the second. Both arguments must be tuple encodings, otherwise a future <a href="#val-construct"><code>construct</code></a>, <a href="#val-destruct"><code>destruct</code></a> or <a href="#val-schema"><code>schema</code></a> will fail with <code>Invalid_argument</code>.</p></div></div><h3 id="json-type-combinators-for-unions"><a href="#json-type-combinators-for-unions" class="anchor"></a>JSON type combinators for unions</h3><div class="odoc-spec"><div class="spec type" id="type-case" class="anchored"><a href="#type-case" class="anchor"></a><code><span><span class="keyword">type</span> <span>'t case</span></span></code></div><div class="spec-doc"><p>A case for describing union types using <a href="#val-union"><code>union</code></a> ans <a href="#val-case"><code>case</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-case" class="anchored"><a href="#val-case" class="anchor"></a><code><span><span class="keyword">val</span> case : <span>?&#8288;title:string <span>&#45;&gt;</span></span> <span>?&#8288;description:string <span>&#45;&gt;</span></span>
<span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span>&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span>&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-case">case</a></span></span></code></div><div class="spec-doc"><p>To be used inside a <a href="#val-union"><code>union</code></a>. Takes a <code>encoding</code> for a specific case, and a converter to and from a type common to all cases (<code>'t</code>). Usually, it consists in boxing / deboxing the specific data in an OCaml sum type constructor.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-union" class="anchored"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span><span><span><span class="type-var">'t</span> <a href="#type-case">case</a></span> list</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A utility to build destructors for custom encoded sum types.</p></div></div><h3 id="json-generic-type-combinators"><a href="#json-generic-type-combinators" class="anchor"></a>JSON generic type combinators</h3><div class="odoc-spec"><div class="spec value" id="val-custom" class="anchored"><a href="#val-custom" class="anchor"></a><code><span><span class="keyword">val</span> custom : <span><span>(<span><span class="type-var">'t</span> <span>&#45;&gt;</span></span> <a href="../Json_repr/index.html#type-ezjsonm">Json_repr.ezjsonm</a>)</span> <span>&#45;&gt;</span></span> <span><span>(<span><a href="../Json_repr/index.html#type-ezjsonm">Json_repr.ezjsonm</a> <span>&#45;&gt;</span></span> <span class="type-var">'t</span>)</span> <span>&#45;&gt;</span></span> <span>schema:<a href="../Json_schema/index.html#type-schema">Json_schema.schema</a> <span>&#45;&gt;</span></span> <span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A simple custom encoding using the <a href="../Json_repr/index.html#type-ezjsonm"><code>Json_repr.ezjsonm</code></a> intermediate representation for the conversion functions. The resulting encoding is usable with any other instanciation of functor <a href="Make/index.html"><code>Make</code></a>, internal conversions may be performed needed. The second transformer function can <code>raise (Cannot_destruct ([ (* location *)], exn))</code> to indicate an error, which will be relocated correctly.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-conv" class="anchored"><a href="#val-conv" class="anchor"></a><code><span><span class="keyword">val</span> conv : <span><span>(<span><span class="type-var">'a</span> <span>&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span>&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span></span> <span>?&#8288;schema:<a href="../Json_schema/index.html#type-schema">Json_schema.schema</a> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding adapter, with an optional handwritten schema. The second transformer function can <code>raise (Cannot_destruct ([], exn))</code> to indicate an error, which will be relocated correctly.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mu" class="anchored"><a href="#val-mu" class="anchor"></a><code><span><span class="keyword">val</span> mu : <span>string <span>&#45;&gt;</span></span> <span>?&#8288;title:string <span>&#45;&gt;</span></span> <span>?&#8288;description:string <span>&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span>)</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A fixpoint combinator. Links a recursive OCaml type to an internal JSON schema reference, by allowing to use the encoding inside its own definition. The first parameter is a path, that must be unique and respect the format of <a href="../Json_schema/index.html#val-add_definition"><code>Json_schema.add_definition</code></a>. It is used to encode the recursivity as a named reference in the JSON schema.</p><p>Here is an example to turn a standard OCaml list into either <code>&quot;nil&quot;</code> for <code>[]</code> or <code>{&quot;hd&quot;:hd,&quot;tl&quot;:tl}</code> for <code>hd::tl</code>.</p><pre><code>let reclist item_encoding =
   mu &quot;list&quot; @@ fun self -&gt;
   union [
      case (string_enum [ &quot;nil&quot;, () ])
         (function [] -&gt; Some () | _ :: _ -&gt; None)
         (fun () -&gt; []) ;
      case (obj2 (req &quot;hd&quot; itemencoding) (req &quot;tl&quot; self))
         (function hd :: tl -&gt; Some (hd, tl) | [] -&gt; None)
         (fun (hd, tl) -&gt; hd :: tl)
   ]</code></pre><p>Notice that the function passed to <code>mu</code> must be pure. Otherwise, the behavior is unspecified.</p><p>A stateful recursive encoding can still be put under a <code>delayed</code> combinator to make sure that a new encoding is generated each time it is used. Caching the encoding generation when the state has not changed is then the responsability of the client.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-any_ezjson_value" class="anchored"><a href="#val-any_ezjson_value" class="anchor"></a><code><span><span class="keyword">val</span> any_ezjson_value : <span><a href="../Json_repr/index.html#type-ezjsonm">Json_repr.ezjsonm</a> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A raw JSON value in ezjsonm representation.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-any_document" class="anchored"><a href="#val-any_document" class="anchor"></a><code><span><span class="keyword">val</span> any_document : <span><a href="../Json_repr/index.html#type-any">Json_repr.any</a> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A valid JSON document (i.e. an array or object value).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-any_schema" class="anchored"><a href="#val-any_schema" class="anchor"></a><code><span><span class="keyword">val</span> any_schema : <span><a href="../Json_schema/index.html#type-schema">Json_schema.schema</a> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>The encoding of a JSON schema, linked to its OCaml definiton.</p></div></div><h3 id="exporting-encodings-as-json-schemas"><a href="#exporting-encodings-as-json-schemas" class="anchor"></a>Exporting <code>encoding</code>s as JSON schemas</h3><div class="odoc-spec"><div class="spec value" id="val-schema" class="anchored"><a href="#val-schema" class="anchor"></a><code><span><span class="keyword">val</span> schema : <span>?&#8288;definitions_path:string <span>&#45;&gt;</span></span> <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <a href="../Json_schema/index.html#type-schema">Json_schema.schema</a></span></code></div><div class="spec-doc"><p>Describe an encoding in JSON schema format. May raise <a href="#exception-Bad_schema"><code>Bad_schema</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-def" class="anchored"><a href="#val-def" class="anchor"></a><code><span><span class="keyword">val</span> def : <span>string <span>&#45;&gt;</span></span> <span>?&#8288;title:string <span>&#45;&gt;</span></span> <span>?&#8288;description:string <span>&#45;&gt;</span></span> <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> <span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Name a definition so its occurences can be shared in the JSON schema. The first parameter is a path, that must be unique and respect the format of <a href="../Json_schema/index.html#val-add_definition"><code>Json_schema.add_definition</code></a>.</p></div></div><h3 id="errors"><a href="#errors" class="anchor"></a>Errors</h3><div class="odoc-spec"><div class="spec exception" id="exception-Cannot_destruct" class="anchored"><a href="#exception-Cannot_destruct" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Cannot_destruct</span> <span class="keyword">of</span> <a href="../Json_query/index.html#type-path">Json_query.path</a> * exn</span></code></div><div class="spec-doc"><p>Exception raised by destructors, with the location in the original JSON structure and the specific error.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Unexpected" class="anchored"><a href="#exception-Unexpected" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Unexpected</span> <span class="keyword">of</span> string * string</span></code></div><div class="spec-doc"><p>Unexpected kind of data encountered (w/ the expectation).</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-No_case_matched" class="anchored"><a href="#exception-No_case_matched" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">No_case_matched</span> <span class="keyword">of</span> <span>exn list</span></span></code></div><div class="spec-doc"><p>Some <a href="#val-union"><code>union</code></a> couldn't be destructed, w/ the reasons for each <a href="#val-case"><code>case</code></a>.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Bad_array_size" class="anchored"><a href="#exception-Bad_array_size" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Bad_array_size</span> <span class="keyword">of</span> int * int</span></code></div><div class="spec-doc"><p>Array of unexpected size encountered (w/ the expectation).</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Missing_field" class="anchored"><a href="#exception-Missing_field" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Missing_field</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>Missing field in an object.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Unexpected_field" class="anchored"><a href="#exception-Unexpected_field" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Unexpected_field</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>Supernumerary field in an object.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Bad_schema" class="anchored"><a href="#exception-Bad_schema" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Bad_schema</span> <span class="keyword">of</span> exn</span></code></div><div class="spec-doc"><p>Bad custom schema encountered.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-print_error" class="anchored"><a href="#val-print_error" class="anchor"></a><code><span><span class="keyword">val</span> print_error : <span>?&#8288;print_unknown:<span>(<span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span></span> <span>exn <span>&#45;&gt;</span></span> unit)</span> <span>&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span></span> <span>exn <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Produces a human readable version of an error.</p></div></div><h3 id="advanced-interface-for-using-a-custom-json-representation"><a href="#advanced-interface-for-using-a-custom-json-representation" class="anchor"></a>Advanced interface for using a custom JSON representation</h3><div class="odoc-spec"><div class="spec module-type" id="module-type-S" class="anchored"><a href="#module-type-S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-S/index.html">S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Make" class="anchored"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-Repr/index.html">Repr</a> : <a href="../Json_repr/module-type-Repr/index.html">Json_repr.Repr</a>) : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-repr_value">repr_value</a> = <a href="Make/argument-1-Repr/index.html#type-value">Repr.value</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-repr_agnostic_custom" class="anchored"><a href="#type-repr_agnostic_custom" class="anchor"></a><code><span><span class="keyword">type</span> <span>'t repr_agnostic_custom</span></span><span> = </span><span>{</span></code><table><tr id="type-repr_agnostic_custom.write" class="anchored"><td class="def record field"><a href="#type-repr_agnostic_custom.write" class="anchor"></a><code><span>write : rt. <span><span>(<span class="keyword">module</span> <a href="../Json_repr/module-type-Repr/index.html">Json_repr.Repr</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Json_repr/module-type-Repr/index.html#type-value">value</a> = <span class="type-var">'rt</span>)</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'t</span> <span>&#45;&gt;</span></span> <span class="type-var">'rt</span>;</span></code></td></tr><tr id="type-repr_agnostic_custom.read" class="anchored"><td class="def record field"><a href="#type-repr_agnostic_custom.read" class="anchor"></a><code><span>read : rf. <span><span>(<span class="keyword">module</span> <a href="../Json_repr/module-type-Repr/index.html">Json_repr.Repr</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Json_repr/module-type-Repr/index.html#type-value">value</a> = <span class="type-var">'rf</span>)</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'rf</span> <span>&#45;&gt;</span></span> <span class="type-var">'t</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Custom encoders for an OCaml type, given both custom conversion functions. The actual representation is not known in advance, so the conversion functions have to examine / construct the JSON value through the first class modules they are passed. The <code>read</code> transformer function can <code>raise (Cannot_destruct ([], &quot;message&quot;))</code> to indicate an error, which will be relocated correctly.</p><p>Here is an example of how to build such a value for a type <code>'t</code>.</p><pre><code>let read
  : type tf. (module Json_repr.Repr with type value = tf) -&gt; tf -&gt; 't
  = fun (module Repr_f) repr -&gt;
    match Repr_f.view repr with
    | `Null (* destruct the JSON using [Repr_f.view] *) -&gt;
      (* create a value of type 't *)
    | _ -&gt;
      (* or fail with this wrapping exception *)
      raise (Cannot_destruct ([ (* location *) ], (* exn *))) in
let write
  : type tf. (module Json_repr.Repr with type value = tf) -&gt; 't -&gt; tf
  = fun (module Repr_f) v -&gt;
    (* examine the value and produce a JSON using [Repr_f.repr] *)
    Repr_f.repr `Null in
{ read ; write } </code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-repr_agnostic_custom" class="anchored"><a href="#val-repr_agnostic_custom" class="anchor"></a><code><span><span class="keyword">val</span> repr_agnostic_custom : <span><span><span class="type-var">'t</span> <a href="#type-repr_agnostic_custom">repr_agnostic_custom</a></span> <span>&#45;&gt;</span></span> <span>schema:<a href="../Json_schema/index.html#type-schema">Json_schema.schema</a> <span>&#45;&gt;</span></span> <span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A custom encoding, using custom encoders and a schema.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-any_value" class="anchored"><a href="#val-any_value" class="anchor"></a><code><span><span class="keyword">val</span> any_value : <span><a href="../Json_repr/index.html#type-any">Json_repr.any</a> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A raw JSON value in its original representation.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_nullable" class="anchored"><a href="#val-is_nullable" class="anchor"></a><code><span><span class="keyword">val</span> is_nullable : <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns <code>true</code> is the encoding might construct <code>null</code>.</p></div></div></div></body></html>