<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parmatch (ocaml.Parmatch)</title><link rel="stylesheet" href="../../odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0-beta2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">ocaml</a> &#x00BB; Parmatch</nav><header class="odoc-preamble"><h1>Module <code><span>Parmatch</span></code></h1><p>Detection of partial matches and unused match cases.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value" id="val-omega" class="anchored"><a href="#val-omega" class="anchor"></a><code><span><span class="keyword">val</span> omega : <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a></span></code></div><div class="spec-doc"><p>aka. &quot;Tpat_any&quot; or &quot;_&quot;</p></div></div><div class="odoc-spec"><div class="spec value" id="val-omegas" class="anchored"><a href="#val-omegas" class="anchor"></a><code><span><span class="keyword">val</span> omegas : <span>int <span>&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span></span></code></div><div class="spec-doc"><p><code>List.init (fun _ -&gt; omega)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-omega_list" class="anchored"><a href="#val-omega_list" class="anchor"></a><code><span><span class="keyword">val</span> omega_list : <span><span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span></span></code></div><div class="spec-doc"><p><code>List.map (fun _ -&gt; omega)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-normalize_pat" class="anchored"><a href="#val-normalize_pat" class="anchor"></a><code><span><span class="keyword">val</span> normalize_pat : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span></span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a></span></code></div><div class="spec-doc"><p>Keep only the &quot;head&quot; of a pattern: all arguments are replaced by <code>omega</code>, so are variables.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_compare" class="anchored"><a href="#val-const_compare" class="anchor"></a><code><span><span class="keyword">val</span> const_compare : <span><a href="../Asttypes/index.html#type-constant">Asttypes.constant</a> <span>&#45;&gt;</span></span> <span><a href="../Asttypes/index.html#type-constant">Asttypes.constant</a> <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>const_compare c1 c2</code> compares the actual values represented by <code>c1</code> and <code>c2</code>, while simply using <code>Stdlib.compare</code> would compare the representations.</p><p>cf. MPR#5758</p></div></div><div class="odoc-spec"><div class="spec value" id="val-le_pat" class="anchored"><a href="#val-le_pat" class="anchor"></a><code><span><span class="keyword">val</span> le_pat : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>le_pat p q</code> means: forall V, V matches q implies V matches p</p></div></div><div class="odoc-spec"><div class="spec value" id="val-le_pats" class="anchored"><a href="#val-le_pats" class="anchor"></a><code><span><span class="keyword">val</span> le_pats : <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span>&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>le_pats (p1 .. pm) (q1 .. qn)</code> means: forall i &lt;= m, <code>le_pat pi qi</code></p></div></div><div class="odoc-spec"><div class="spec module" id="module-Compat" class="anchored"><a href="#module-Compat" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Compat/index.html">Compat</a></span><span> (<a href="Compat/argument-1-_/index.html">_</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Exported compatibility functor, abstracted over constructor equality</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Empty" class="anchored"><a href="#exception-Empty" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Empty</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-lub" class="anchored"><a href="#val-lub" class="anchor"></a><code><span><span class="keyword">val</span> lub : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span></span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a></span></code></div><div class="spec-doc"><p><code>lub p q</code> is a pattern that matches all values matched by <code>p</code> and <code>q</code>. May raise <code>Empty</code>, when <code>p</code> and <code>q</code> are not compatible.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lubs" class="anchored"><a href="#val-lubs" class="anchor"></a><code><span><span class="keyword">val</span> lubs : <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span>&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span>&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span></span></code></div><div class="spec-doc"><p><code>lubs [p1; ...; pn] [q1; ...; qk]</code>, where <code>n &lt; k</code>, is <code>[lub p1 q1; ...; lub pk qk]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_mins" class="anchored"><a href="#val-get_mins" class="anchor"></a><code><span><span class="keyword">val</span> get_mins : <span><span>(<span><span class="type-var">'a</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span>&#45;&gt;</span></span> bool)</span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-set_args" class="anchored"><a href="#val-set_args" class="anchor"></a><code><span><span class="keyword">val</span> set_args : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span>&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span></span></code></div><div class="spec-doc"><p>Those two functions recombine one pattern and its arguments: For instance: (_,_)::p1::p2::rem -&gt; (p1, p2)::rem The second one will replace mutable arguments by '_'</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_args_erase_mutable" class="anchored"><a href="#val-set_args_erase_mutable" class="anchor"></a><code><span><span class="keyword">val</span> set_args_erase_mutable : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span>&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pat_of_constr" class="anchored"><a href="#val-pat_of_constr" class="anchor"></a><code><span><span class="keyword">val</span> pat_of_constr : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span></span> <span><a href="../Types/index.html#type-constructor_description">Types.constructor_description</a> <span>&#45;&gt;</span></span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-complete_constrs" class="anchored"><a href="#val-complete_constrs" class="anchor"></a><code><span><span class="keyword">val</span> complete_constrs : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span></span> <span><span><a href="../Types/index.html#type-constructor_tag">Types.constructor_tag</a> list</span> <span>&#45;&gt;</span></span> <span><a href="../Types/index.html#type-constructor_description">Types.constructor_description</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-ppat_of_type" class="anchored"><a href="#val-ppat_of_type" class="anchor"></a><code><span><span class="keyword">val</span> ppat_of_type : <span><a href="../Env/index.html#type-t">Env.t</a> <span>&#45;&gt;</span></span> <span><a href="../Types/index.html#type-type_expr">Types.type_expr</a> <span>&#45;&gt;</span></span> <a href="../Parsetree/index.html#type-pattern">Parsetree.pattern</a> * <span><span>(string, <a href="../Types/index.html#type-constructor_description">Types.constructor_description</a>)</span> <a href="../Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a></span> * <span><span>(string, <a href="../Types/index.html#type-label_description">Types.label_description</a>)</span> <a href="../Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a></span></span></code></div><div class="spec-doc"><p><code>ppat_of_type</code> builds an untyped or-pattern from its expected type. May raise <code>Empty</code> when <code>type_expr</code> is an empty variant</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pressure_variants" class="anchored"><a href="#val-pressure_variants" class="anchor"></a><code><span><span class="keyword">val</span> pressure_variants : <span><a href="../Env/index.html#type-t">Env.t</a> <span>&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span>&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-check_partial" class="anchored"><a href="#val-check_partial" class="anchor"></a><code><span><span class="keyword">val</span> check_partial : <span><span>(<span><span><span>(string, <a href="../Types/index.html#type-constructor_description">Types.constructor_description</a>)</span> <a href="../Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a></span> <span>&#45;&gt;</span></span> <span><span><span>(string, <a href="../Types/index.html#type-label_description">Types.label_description</a>)</span> <a href="../Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a></span> <span>&#45;&gt;</span></span> <span><a href="../Parsetree/index.html#type-pattern">Parsetree.pattern</a> <span>&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> option</span>)</span> <span>&#45;&gt;</span></span> <span><a href="../Location/index.html#type-t">Location.t</a> <span>&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-case">Typedtree.case</a> list</span> <span>&#45;&gt;</span></span> <a href="../Typedtree/index.html#type-partial">Typedtree.partial</a></span></code></div><div class="spec-doc"><p><code>check_partial pred loc caselist</code> and <code>check_unused refute pred caselist</code> are called with a function <code>pred</code> which will be given counter-example candidates: they may be partially ill-typed, and have to be type-checked to extract a valid counter-example. <code>pred</code> returns a valid counter-example or <code>None</code>. <code>refute</code> indicates that <code>check_unused</code> was called on a refutation clause.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_unused" class="anchored"><a href="#val-check_unused" class="anchor"></a><code><span><span class="keyword">val</span> check_unused : <span><span>(<span>bool <span>&#45;&gt;</span></span> <span><span><span>(string, <a href="../Types/index.html#type-constructor_description">Types.constructor_description</a>)</span> <a href="../Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a></span> <span>&#45;&gt;</span></span> <span><span><span>(string, <a href="../Types/index.html#type-label_description">Types.label_description</a>)</span> <a href="../Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a></span> <span>&#45;&gt;</span></span> <span><a href="../Parsetree/index.html#type-pattern">Parsetree.pattern</a> <span>&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> option</span>)</span> <span>&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-case">Typedtree.case</a> list</span> <span>&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-irrefutable" class="anchored"><a href="#val-irrefutable" class="anchor"></a><code><span><span class="keyword">val</span> irrefutable : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-inactive" class="anchored"><a href="#val-inactive" class="anchor"></a><code><span><span class="keyword">val</span> inactive : <span>partial:<a href="../Typedtree/index.html#type-partial">Typedtree.partial</a> <span>&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>An inactive pattern is a pattern, matching against which can be duplicated, erased or delayed without change in observable behavior of the program. Patterns containing (lazy _) subpatterns or reads of mutable fields are active.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_ambiguous_bindings" class="anchored"><a href="#val-check_ambiguous_bindings" class="anchor"></a><code><span><span class="keyword">val</span> check_ambiguous_bindings : <span><span><a href="../Typedtree/index.html#type-case">Typedtree.case</a> list</span> <span>&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-some_private_tag" class="anchored"><a href="#val-some_private_tag" class="anchor"></a><code><span><span class="keyword">val</span> some_private_tag : <a href="../Asttypes/index.html#type-label">Asttypes.label</a></span></code></div></div></div></body></html>