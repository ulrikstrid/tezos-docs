<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CACHE_MAP (ringo-lwt.Ringo_lwt.Sigs.CACHE_MAP)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0-beta2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">ringo-lwt</a> &#x00BB; <a href="../../index.html">Ringo_lwt</a> &#x00BB; <a href="../index.html">Sigs</a> &#x00BB; CACHE_MAP</nav><header class="odoc-preamble"><h1>Module type <code><span>Sigs.CACHE_MAP</span></code></h1></header><div class="odoc-content"><p>A Mutable structure akin to a <code>Ringo.CACHE_MAP</code> but with Lwt-aware functions. E.g., consider the following use of a <code>Ringo.CACHE_MAP</code>:</p><p><code>let c = Ringo_map.create 1024 in
        let resolve k =
           match Ringo_map.find_opt k with
           | Some v -&gt; Lwt.return v
           | None -&gt;
                 do_resolve k &gt;&gt;= fun v -&gt;
                 Ringo_map.replace c k v;
                 Lwt.return v</code></p><p>In this example, there is a race condition: if <code>do_resolve</code> takes time to complete, another call to <code>resolve</code> may be made concurrently to the first one.</p><p>The function <code>find_or_replace</code> in <code>Ringo_lwt.CACHE_MAP</code> works around this issue.</p><div class="odoc-spec"><div class="spec type" id="type-key" class="anchored"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> key</span></code></div><div class="spec-doc"><p>The type of keys on which values in the cache are indexed.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>The type of Lwt-friendly caches holding bindings from <code>key</code> to <code>'a</code>.</p><p>Instead of adding values directly to this cache, you can add promises (using <code>replace</code>) or, more interestingly, atomically (a) querying for an already bound promises or (b) generating a new one if needed. This helps avoid race conditions.</p><p>A promise is removed from the cache if:</p><ul><li>The cache overflows (in which case, the removal of the promise depends on the policies of the cache, see <a href="../../../../ringo/Ringo/module-type-CACHE_MAP/index.html"><code>Ringo.CACHE_MAP</code></a> for details).</li><li>The promise is still held by the cache when</li><li>the cache is <code>clear</code>ed (in which case the promise is canceled).</li><li>it is <code>replace</code>d by another one (in which case it is canceled).</li><li>it is explicitly <code>remove</code>d (in which case it is canceled).</li><li>it is rejected.</li></ul><p>If a promise is not held by the cache, then it cannot be removed from the cache and it will not be canceled by the cache.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span>&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>create n</code> creates a cache with a size-bound of <code>n</code>. Remember that the size-bound is not upheld strictly by all caches.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-replace" class="anchored"><a href="#val-replace" class="anchor"></a><code><span><span class="keyword">val</span> replace : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span> <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>replace c k p</code> binds the key <code>k</code> to <code>p</code> in the cache <code>c</code>.</p><p>Note that when a promise is rejected, it is automatically removed from the cache.</p><p>Note that, for the purpose of determining if an inserted binding is supernumerary, and thus if it pushes another binding out of the cache, an unresolved binding counts fully.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><a href="#type-key">key</a> <span>&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>fold f c init</code> folds the function <code>f</code> and value <code>init</code> over the bindings of <code>c</code>. More specifically, it takes the bindings that are in <code>c</code> at the moment of the call (inserting a binding whilst the <code>fold</code> promise is pending has no effect on the <code>fold</code> promise) and traverses them sequentially: it waits for one step of the folding to resolve before starting the next one. Promises that are rejected are not visible by this <code>fold</code> operation: they are simply ignored.</p><p>E.g., you can run <code>fold (fun _ _ () -&gt; Lwt.return_unit) ()</code> to wait for all currently-held bindings to resolve.</p><p>Note that for some caches, this function may fold over a subset of the bindings of <code>c</code>. Specifically, on caches with a <code>Weak</code> overflow policy, only the strongly-held elements are folded over.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_promises" class="anchored"><a href="#val-fold_promises" class="anchor"></a><code><span><span class="keyword">val</span> fold_promises : <span><span>(<span><a href="#type-key">key</a> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span> <span>&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span>&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span>&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>fold_promises f c init</code> folds the function <code>f</code> and value <code>init</code> over the promises of bindings of <code>c</code>. More specifically, it takes the bindings that are in <code>c</code> at the moment of the call (inserting a binding whilst the <code>fold</code> promise is pending has no effect on the <code>fold</code> promise) and traverses them all immediately. The function that folds over the bindings is given the promises (rather than the values these promises resolve to).</p><p>E.g., You can count the number of resolved/pending like so: <code>fold_promises
        (fun _ p (sleeping, not_sleeping) -&gt;
           match Lwt.state p with
           | Sleep -&gt; (sleeping + 1, not_sleeping)
           | Return _ -&gt; (sleeping, not_sleeping + 1)
           | Fail _ -&gt; assert false (* these are removed from the cache *)
         )
         c
         (0, 0)
      </code></p><p>Note that for some caches, this function may fold over a subset of the bindings of <code>c</code>. Specifically, on caches with a <code>Weak</code> overflow policy, only the strongly-held elements are folded over.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_opt" class="anchored"><a href="#val-find_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_opt : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span> option</span></span></code></div><div class="spec-doc"><p><code>find_opt c k</code> is <code>None</code> if <code>k</code> is not bound in <code>c</code>. Otherwise it is <code>Some p</code> where <code>p</code> is bound to <code>k</code> in <code>c</code>.</p><p>Note that the in some caches, this may have a side effect on the <code>k</code>-to-<code>v</code> binding. Specifically, in some caches, it might make it less likely to be removed when supernumerary bindings are inserted.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_or_replace" class="anchored"><a href="#val-find_or_replace" class="anchor"></a><code><span><span class="keyword">val</span> find_or_replace : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span>&#45;&gt;</span></span> <span><span>(<span><a href="#type-key">key</a> <span>&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>find_or_replace c k f</code> behaves likes <code>find_opt c k</code> if <code>k</code> is bound in <code>c</code>, and it behaves like <code>replace c k f</code> otherwise. Either way, it returns the promise that resolves to the value associated to <code>k</code> whichever behavior <code>find_or_replace</code> resembled.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove" class="anchored"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>remove c k</code> removes the binding from <code>k</code> in <code>c</code>. If <code>k</code> is not bound in <code>c</code>, it does nothing. If the binding is not resolved yet, it also cancels the promise.</p><p>Note that in some caches, removed bindings can still count towards the size bound for some time.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length c</code> is the number of bindings held by <code>c</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-capacity" class="anchored"><a href="#val-capacity" class="anchor"></a><code><span><span class="keyword">val</span> capacity : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>capacity c</code> is the number of bindings <code>c</code> can hold: <code>capacity (create n) = n</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-clear" class="anchored"><a href="#val-clear" class="anchor"></a><code><span><span class="keyword">val</span> clear : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>clear c</code> removes all bindings from <code>c</code>. It also cancels unresolved bindings.</p></div></div></div></body></html>