<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Raw_grammar (sexplib.Sexplib.Pre_sexp.Raw_grammar)</title><link rel="stylesheet" href="../../../../odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0-beta2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">sexplib</a> &#x00BB; <a href="../../index.html">Sexplib</a> &#x00BB; <a href="../index.html">Pre_sexp</a> &#x00BB; Raw_grammar</nav><header class="odoc-preamble"><h1>Module <code><span>Pre_sexp.Raw_grammar</span></code></h1></header><div class="odoc-content"><div class="odoc-include"><div class="spec include"><div class="doc"><div class="odoc-spec"><div class="spec type" id="type-label" class="anchored"><a href="#type-label" class="anchor"></a><code><span><span class="keyword">type</span> label</span><span> = string</span></code></div><div class="spec-doc"><p>The label of a field, constructor, or constant.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-generic_group_id" class="anchored"><a href="#type-generic_group_id" class="anchor"></a><code><span><span class="keyword">type</span> generic_group_id</span><span> = string</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-group_id" class="anchored"><a href="#type-group_id" class="anchor"></a><code><span><span class="keyword">type</span> group_id</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-var_name" class="anchored"><a href="#type-var_name" class="anchor"></a><code><span><span class="keyword">type</span> var_name</span><span> = string</span></code></div><div class="spec-doc"><p>Variable names. These are used to improve readability of the printed grammars. Internally, we use numerical indices to represent variables; see <code>Implicit_var</code> below.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-type_name" class="anchored"><a href="#type-type_name" class="anchor"></a><code><span><span class="keyword">type</span> type_name</span><span> = string</span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Atom" class="anchored"><a href="#module-Atom" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Atom/index.html">Atom</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A grammatical type which classifies atoms.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-type_" class="anchored"><a href="#type-type_" class="anchor"></a><code><span><span class="keyword">type</span> <span>'t type_</span></span><span> = </span></code><table><tr id="type-type_.Any" class="anchored"><td class="def variant constructor"><a href="#type-type_.Any" class="anchor"></a><code><span>| </span><span><span class="constructor">Any</span></span></code></td><td class="doc"><p>Any list or atom.</p></td></tr><tr id="type-type_.Apply" class="anchored"><td class="def variant constructor"><a href="#type-type_.Apply" class="anchor"></a><code><span>| </span><span><span class="constructor">Apply</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span> * <span><span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span> list</span></span></code></td><td class="doc"><p>Assign types to (explicit) type variables.</p></td></tr><tr id="type-type_.Atom" class="anchored"><td class="def variant constructor"><a href="#type-type_.Atom" class="anchor"></a><code><span>| </span><span><span class="constructor">Atom</span> <span class="keyword">of</span> <a href="Atom/index.html#type-t">Atom.t</a></span></code></td><td class="doc"><p>An atom, in particular one of the given <a href="Atom/index.html#type-t"><code>Atom.t</code></a>.</p></td></tr><tr id="type-type_.Explicit_bind" class="anchored"><td class="def variant constructor"><a href="#type-type_.Explicit_bind" class="anchor"></a><code><span>| </span><span><span class="constructor">Explicit_bind</span> <span class="keyword">of</span> <span><a href="#type-var_name">var_name</a> list</span> * <span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span></span></code></td><td class="doc"><p>In <code>Bind ([ &quot;a&quot;; &quot;b&quot; ], Explicit_var 0)</code>, <code>Explicit_var 0</code> is <code>&quot;a&quot;</code>. One must bind all available type variables: free variables are not permitted.</p></td></tr><tr id="type-type_.Explicit_var" class="anchored"><td class="def variant constructor"><a href="#type-type_.Explicit_var" class="anchor"></a><code><span>| </span><span><span class="constructor">Explicit_var</span> <span class="keyword">of</span> int</span></code></td><td class="doc"><p>Indices for type variables, e.g. <code>'a</code>, introduced by polymorphic definitions.</p><p>Unlike de Bruijn indices, these are always bound by the nearest ancestral <code>Explicit_bind</code>.</p></td></tr><tr id="type-type_.Grammar" class="anchored"><td class="def variant constructor"><a href="#type-type_.Grammar" class="anchor"></a><code><span>| </span><span><span class="constructor">Grammar</span> <span class="keyword">of</span> <span class="type-var">'t</span></span></code></td><td class="doc"><p>Embeds other types in a grammar.</p></td></tr><tr id="type-type_.Implicit_var" class="anchored"><td class="def variant constructor"><a href="#type-type_.Implicit_var" class="anchor"></a><code><span>| </span><span><span class="constructor">Implicit_var</span> <span class="keyword">of</span> int</span></code></td><td class="doc"><p>Indices for type constructors, e.g. <code>int</code>, in scope. Unlike de Bruijn indices, these are always bound by the <code>implicit_vars</code> of the nearest enclosing <code>generic_groups</code>.</p></td></tr><tr id="type-type_.List" class="anchored"><td class="def variant constructor"><a href="#type-type_.List" class="anchor"></a><code><span>| </span><span><span class="constructor">List</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-sequence_type">sequence_type</a></span></span></code></td><td class="doc"><p>A list of a certain form. Depending on the <a href="#type-sequence_type"><code>sequence_type</code></a>, this might correspond to an OCaml tuple, list, or embedded record.</p></td></tr><tr id="type-type_.Option" class="anchored"><td class="def variant constructor"><a href="#type-type_.Option" class="anchor"></a><code><span>| </span><span><span class="constructor">Option</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span></span></code></td><td class="doc"><p>An optional value. Either syntax recognized by <code>option_of_sexp</code> is supported: <code>(Some 42)</code> or <code>(42)</code> for a value and <code>None</code> or <code>()</code> for no value.</p></td></tr><tr id="type-type_.Record" class="anchored"><td class="def variant constructor"><a href="#type-type_.Record" class="anchor"></a><code><span>| </span><span><span class="constructor">Record</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-record_type">record_type</a></span></span></code></td><td class="doc"><p>A list of lists, representing a record of the given <a href="#type-record_type"><code>record_type</code></a>. For validation, <code>Record recty</code> is equivalent to <code>List [Fields recty]</code>.</p></td></tr><tr id="type-type_.Recursive" class="anchored"><td class="def variant constructor"><a href="#type-type_.Recursive" class="anchor"></a><code><span>| </span><span><span class="constructor">Recursive</span> <span class="keyword">of</span> <a href="#type-type_name">type_name</a></span></code></td><td class="doc"><p>A type in the same mutually recursive group, possibly the current one.</p></td></tr><tr id="type-type_.Union" class="anchored"><td class="def variant constructor"><a href="#type-type_.Union" class="anchor"></a><code><span>| </span><span><span class="constructor">Union</span> <span class="keyword">of</span> <span><span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span> list</span></span></code></td><td class="doc"><p>Any sexp matching any of the given types. <a href="#type-type_.Variant"><code>Variant</code></a> should be preferred when possible, especially for complex types, since validation and other algorithms may behave exponentially.</p><p>One useful special case is <code>Union []</code>, the empty type. This is occasionally generated for things such as abstract types.</p></td></tr><tr id="type-type_.Variant" class="anchored"><td class="def variant constructor"><a href="#type-type_.Variant" class="anchor"></a><code><span>| </span><span><span class="constructor">Variant</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-variant_type">variant_type</a></span></span></code></td><td class="doc"><p>A sexp which matches the given <a href="#type-variant_type"><code>variant_type</code></a>.</p></td></tr></table></div><div class="spec-doc"><p>A grammatical type which classifies sexps. Corresponds to a non-terminal in a context-free grammar.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-sequence_type" class="anchored"><a href="#type-sequence_type" class="anchor"></a><code><span><span class="keyword">and</span> <span>'t sequence_type</span></span><span> = <span><span><span class="type-var">'t</span> <a href="#type-component">component</a></span> list</span></span></code></div><div class="spec-doc"><p>A grammatical type which classifies sequences of sexps. Here, a &quot;sequence&quot; may mean either a list on its own or, say, the sexps following a constructor in a list matching a <a href="#type-variant_type"><code>variant_type</code></a>.</p><p>Certain operations may greatly favor simple sequence types. For example, matching <code>List [ Many type_ ]</code> is easy for any type <code>type_</code> (assuming <code>type_</code> itself is easy), but <code>List [ Many type1; Many type2 ]</code> may require backtracking. Grammars derived from OCaml types will only have &quot;nice&quot; sequence types.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-component" class="anchored"><a href="#type-component" class="anchor"></a><code><span><span class="keyword">and</span> <span>'t component</span></span><span> = </span></code><table><tr id="type-component.One" class="anchored"><td class="def variant constructor"><a href="#type-component.One" class="anchor"></a><code><span>| </span><span><span class="constructor">One</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span></span></code></td><td class="doc"><p>Exactly one sexp of the given type.</p></td></tr><tr id="type-component.Optional" class="anchored"><td class="def variant constructor"><a href="#type-component.Optional" class="anchor"></a><code><span>| </span><span><span class="constructor">Optional</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span></span></code></td><td class="doc"><p>One sexp of the given type, or nothing at all.</p></td></tr><tr id="type-component.Many" class="anchored"><td class="def variant constructor"><a href="#type-component.Many" class="anchor"></a><code><span>| </span><span><span class="constructor">Many</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span></span></code></td><td class="doc"><p>Any number of sexps, each of the given type.</p></td></tr><tr id="type-component.Fields" class="anchored"><td class="def variant constructor"><a href="#type-component.Fields" class="anchor"></a><code><span>| </span><span><span class="constructor">Fields</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-record_type">record_type</a></span></span></code></td><td class="doc"><p>A succession of lists, collectively defining a record of the given <a href="#type-record_type"><code>record_type</code></a>. The fields may appear in any order. The number of lists is not necessarily fixed, as some fields may be optional. In particular, if all fields are optional, there may be zero lists.</p></td></tr></table></div><div class="spec-doc"><p>Part of a sequence of sexps.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-variant_type" class="anchored"><a href="#type-variant_type" class="anchor"></a><code><span><span class="keyword">and</span> <span>'t variant_type</span></span><span> = </span><span>{</span></code><table><tr id="type-variant_type.ignore_capitalization" class="anchored"><td class="def record field"><a href="#type-variant_type.ignore_capitalization" class="anchor"></a><code><span>ignore_capitalization : bool;</span></code></td><td class="doc"><p>If true, the grammar is insensitive to the case of the first letter of the label. This matches the behavior of derived <code>sexp_of_t</code> functions.</p></td></tr><tr id="type-variant_type.alts" class="anchored"><td class="def record field"><a href="#type-variant_type.alts" class="anchor"></a><code><span>alts : <span><span>(<a href="#type-label">label</a> * <span><span class="type-var">'t</span> <a href="#type-sequence_type">sequence_type</a></span>)</span> list</span>;</span></code></td><td class="doc"><p>An association list of labels (constructors) to sequence types. A matching sexp is a list whose head is the label as an atom and whose tail matches the given sequence type. As a special case, an alternative whose sequence is empty matches an atom rather than a list (i.e., <code>label</code> rather than <code>(label)</code>). This is in keeping with generated <code>t_of_sexp</code> functions.</p><p>As a workaround, to match <code>(label)</code> one could use <code>(&quot;label&quot;, [ Optional (Union []) ])</code>.</p></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>A tagged union of grammatical types. Grammars derived from OCaml variants will have variant types.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-record_type" class="anchored"><a href="#type-record_type" class="anchor"></a><code><span><span class="keyword">and</span> <span>'t record_type</span></span><span> = </span><span>{</span></code><table><tr id="type-record_type.allow_extra_fields" class="anchored"><td class="def record field"><a href="#type-record_type.allow_extra_fields" class="anchor"></a><code><span>allow_extra_fields : bool;</span></code></td></tr><tr id="type-record_type.fields" class="anchored"><td class="def record field"><a href="#type-record_type.fields" class="anchor"></a><code><span>fields : <span><span>(<a href="#type-label">label</a> * <span><span class="type-var">'t</span> <a href="#type-field">field</a></span>)</span> list</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>A collection of field definitions specifying a record type. Consists only of an association list from labels to fields.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-field" class="anchored"><a href="#type-field" class="anchor"></a><code><span><span class="keyword">and</span> <span>'t field</span></span><span> = </span><span>{</span></code><table><tr id="type-field.optional" class="anchored"><td class="def record field"><a href="#type-field.optional" class="anchor"></a><code><span>optional : bool;</span></code></td><td class="doc"><p>If true, the field is optional.</p></td></tr><tr id="type-field.args" class="anchored"><td class="def record field"><a href="#type-field.args" class="anchor"></a><code><span>args : <span><span class="type-var">'t</span> <a href="#type-sequence_type">sequence_type</a></span>;</span></code></td><td class="doc"><p>A sequence type which the arguments to the field must match. An empty sequence is permissible but would not be generated for any OCaml type.</p></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>A field in a record.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = </span></code><table><tr id="type-t.Ref" class="anchored"><td class="def variant constructor"><a href="#type-t.Ref" class="anchor"></a><code><span>| </span><span><span class="constructor">Ref</span> <span class="keyword">of</span> <a href="#type-type_name">type_name</a> * <a href="#type-group">group</a></span></code></td></tr><tr id="type-t.Inline" class="anchored"><td class="def variant constructor"><a href="#type-t.Inline" class="anchor"></a><code><span>| </span><span><span class="constructor">Inline</span> <span class="keyword">of</span> <span><a href="#type-t">t</a> <a href="#type-type_">type_</a></span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-group" class="anchored"><a href="#type-group" class="anchor"></a><code><span><span class="keyword">and</span> group</span><span> = </span><span>{</span></code><table><tr id="type-group.gid" class="anchored"><td class="def record field"><a href="#type-group.gid" class="anchor"></a><code><span>gid : <a href="#type-group_id">group_id</a>;</span></code></td></tr><tr id="type-group.generic_group" class="anchored"><td class="def record field"><a href="#type-group.generic_group" class="anchor"></a><code><span>generic_group : <a href="#type-generic_group">generic_group</a>;</span></code></td></tr><tr id="type-group.origin" class="anchored"><td class="def record field"><a href="#type-group.origin" class="anchor"></a><code><span>origin : string;</span></code></td><td class="doc"><p><code>origin</code> provides a human-readable hint as to where the type was defined.</p><p>For a globally unique identifier, use <code>gid</code> instead.</p><p>See <code>ppx/ppx_sexp_conv/test/expect/test_origin.ml</code> for examples.</p></td></tr><tr id="type-group.apply_implicit" class="anchored"><td class="def record field"><a href="#type-group.apply_implicit" class="anchor"></a><code><span>apply_implicit : <span><a href="#type-t">t</a> list</span>;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-generic_group" class="anchored"><a href="#type-generic_group" class="anchor"></a><code><span><span class="keyword">and</span> generic_group</span><span> = </span><span>{</span></code><table><tr id="type-generic_group.implicit_vars" class="anchored"><td class="def record field"><a href="#type-generic_group.implicit_vars" class="anchor"></a><code><span>implicit_vars : <span><a href="#type-var_name">var_name</a> list</span>;</span></code></td></tr><tr id="type-generic_group.ggid" class="anchored"><td class="def record field"><a href="#type-generic_group.ggid" class="anchor"></a><code><span>ggid : <a href="#type-generic_group_id">generic_group_id</a>;</span></code></td></tr><tr id="type-generic_group.types" class="anchored"><td class="def record field"><a href="#type-generic_group.types" class="anchor"></a><code><span>types : <span><span>(<a href="#type-type_name">type_name</a> * <span><a href="#type-t">t</a> <a href="#type-type_">type_</a></span>)</span> list</span>;</span></code></td></tr></table><code><span>}</span></code></div></div></div></div></div><div class="odoc-spec"><div class="spec module" id="module-Builtin" class="anchored"><a href="#module-Builtin" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Builtin/index.html">Builtin</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-empty_sexp_grammar" class="anchored"><a href="#val-empty_sexp_grammar" class="anchor"></a><code><span><span class="keyword">val</span> empty_sexp_grammar : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-opaque_sexp_grammar" class="anchored"><a href="#val-opaque_sexp_grammar" class="anchor"></a><code><span><span class="keyword">val</span> opaque_sexp_grammar : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fun_sexp_grammar" class="anchored"><a href="#val-fun_sexp_grammar" class="anchor"></a><code><span><span class="keyword">val</span> fun_sexp_grammar : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-tuple2_sexp_grammar" class="anchored"><a href="#val-tuple2_sexp_grammar" class="anchor"></a><code><span><span class="keyword">val</span> tuple2_sexp_grammar : <a href="#type-t">t</a></span></code></div></div></div></body></html>