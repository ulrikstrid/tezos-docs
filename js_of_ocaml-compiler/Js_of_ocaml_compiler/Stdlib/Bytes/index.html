<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bytes (js_of_ocaml-compiler.Js_of_ocaml_compiler.Stdlib.Bytes)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0-beta2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">js_of_ocaml-compiler</a> &#x00BB; <a href="../../index.html">Js_of_ocaml_compiler</a> &#x00BB; <a href="../index.html">Stdlib</a> &#x00BB; Bytes</nav><header class="odoc-preamble"><h1>Module <code><span>Stdlib.Bytes</span></code></h1></header><div class="odoc-content"><div class="odoc-include"><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <span class="keyword">struct</span> <span class="keyword">include</span> <a href="../../../../ocaml/Stdlib/BytesLabels/index.html">Stdlib.BytesLabels</a> <span class="keyword">end</span></span></code></span></summary><div class="odoc-spec"><div class="spec external" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span>bytes <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the length (number of bytes) of the argument.</p></div></div><div class="odoc-spec"><div class="spec external" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p><code>get s n</code> returns the byte at index <code>n</code> in argument <code>s</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec external" id="val-set" class="anchored"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set s n c</code> modifies <code>s</code> in place, replacing the byte at index <code>n</code> with <code>c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec external" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>create n</code> returns a new byte sequence of length <code>n</code>. The sequence is uninitialized and contains arbitrary bytes.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><code>Sys</code>.max_string_length.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>make n c</code> returns a new byte sequence of length <code>n</code>, filled with the byte <code>c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><code>Sys</code>.max_string_length.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span>int <span>&#45;&gt;</span></span> <span>f:<span>(<span>int <span>&#45;&gt;</span></span> char)</span> <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>init n f</code> returns a fresh byte sequence of length <code>n</code>, with character <code>i</code> initialized to the result of <code>f i</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><code>Sys</code>.max_string_length.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : bytes</span></code></div><div class="spec-doc"><p>A byte sequence of size 0.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-copy" class="anchored"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a new byte sequence that contains the same bytes as the argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>string <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a new byte sequence that contains the same bytes as the given string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span>bytes <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a new string that contains the same bytes as the given byte sequence.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sub" class="anchored"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span>bytes <span>&#45;&gt;</span></span> <span>pos:int <span>&#45;&gt;</span></span> <span>len:int <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>sub s start len</code> returns a new byte sequence of length <code>len</code>, containing the subsequence of <code>s</code> that starts at position <code>start</code> and has length <code>len</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sub_string" class="anchored"><a href="#val-sub_string" class="anchor"></a><code><span><span class="keyword">val</span> sub_string : <span>bytes <span>&#45;&gt;</span></span> <span>pos:int <span>&#45;&gt;</span></span> <span>len:int <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Same as <code>sub</code> but return a string instead of a byte sequence.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-extend" class="anchored"><a href="#val-extend" class="anchor"></a><code><span><span class="keyword">val</span> extend : <span>bytes <span>&#45;&gt;</span></span> <span>left:int <span>&#45;&gt;</span></span> <span>right:int <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>extend s left right</code> returns a new byte sequence that contains the bytes of <code>s</code>, with <code>left</code> uninitialized bytes prepended and <code>right</code> uninitialized bytes appended to it. If <code>left</code> or <code>right</code> is negative, then bytes are removed (instead of appended) from the corresponding side of <code>s</code>.</p><p>Raise <code>Invalid_argument</code> if the result length is negative or longer than <code>Sys</code>.max_string_length bytes.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-fill" class="anchored"><a href="#val-fill" class="anchor"></a><code><span><span class="keyword">val</span> fill : <span>bytes <span>&#45;&gt;</span></span> <span>pos:int <span>&#45;&gt;</span></span> <span>len:int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>fill s start len c</code> modifies <code>s</code> in place, replacing <code>len</code> characters with <code>c</code>, starting at <code>start</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-blit" class="anchored"><a href="#val-blit" class="anchor"></a><code><span><span class="keyword">val</span> blit : <span>src:bytes <span>&#45;&gt;</span></span> <span>src_pos:int <span>&#45;&gt;</span></span> <span>dst:bytes <span>&#45;&gt;</span></span> <span>dst_pos:int <span>&#45;&gt;</span></span> <span>len:int <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from sequence <code>src</code>, starting at index <code>srcoff</code>, to sequence <code>dst</code>, starting at index <code>dstoff</code>. It works correctly even if <code>src</code> and <code>dst</code> are the same byte sequence, and the source and destination intervals overlap.</p><p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-blit_string" class="anchored"><a href="#val-blit_string" class="anchor"></a><code><span><span class="keyword">val</span> blit_string : <span>src:string <span>&#45;&gt;</span></span> <span>src_pos:int <span>&#45;&gt;</span></span> <span>dst:bytes <span>&#45;&gt;</span></span> <span>dst_pos:int <span>&#45;&gt;</span></span> <span>len:int <span>&#45;&gt;</span></span>
unit</span></code></div><div class="spec-doc"><p><code>blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from string <code>src</code>, starting at index <code>srcoff</code>, to byte sequence <code>dst</code>, starting at index <code>dstoff</code>.</p><p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span>sep:bytes <span>&#45;&gt;</span></span> <span><span>bytes list</span> <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>concat sep sl</code> concatenates the list of byte sequences <code>sl</code>, inserting the separator byte sequence <code>sep</code> between each, and returns the result as a new byte sequence.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cat" class="anchored"><a href="#val-cat" class="anchor"></a><code><span><span class="keyword">val</span> cat : <span>bytes <span>&#45;&gt;</span></span> <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>cat s1 s2</code> concatenates <code>s1</code> and <code>s2</code> and returns the result as new byte sequence.</p><p>Raise <code>Invalid_argument</code> if the result is longer than <code>Sys</code>.max_string_length bytes.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span>f:<span>(<span>char <span>&#45;&gt;</span></span> unit)</span> <span>&#45;&gt;</span></span> <span>bytes <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code>. It is equivalent to <code>f (get s 0); f (get s 1); ...; f (get s
    (length s - 1)); ()</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span>f:<span>(<span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> unit)</span> <span>&#45;&gt;</span></span> <span>bytes <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <a href="#val-iter"><code>Bytes.iter</code></a>, but the function is applied to the index of the byte as first argument and the byte itself as second argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span>f:<span>(<span>char <span>&#45;&gt;</span></span> char)</span> <span>&#45;&gt;</span></span> <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>map f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code> and stores the resulting bytes in a new sequence that is returned as the result.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span>f:<span>(<span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> char)</span> <span>&#45;&gt;</span></span> <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>mapi f s</code> calls <code>f</code> with each character of <code>s</code> and its index (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-trim" class="anchored"><a href="#val-trim" class="anchor"></a><code><span><span class="keyword">val</span> trim : <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, without leading and trailing whitespace. The bytes regarded as whitespace are the ASCII characters <code>' '</code>, <code>'\012'</code>, <code>'\n'</code>, <code>'\r'</code>, and <code>'\t'</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-escaped" class="anchored"><a href="#val-escaped" class="anchor"></a><code><span><span class="keyword">val</span> escaped : <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-index" class="anchored"><a href="#val-index" class="anchor"></a><code><span><span class="keyword">val</span> index : <span>bytes <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>index s c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code>.</p><p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-index_opt" class="anchored"><a href="#val-index_opt" class="anchor"></a><code><span><span class="keyword">val</span> index_opt : <span>bytes <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index_opt s c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex" class="anchored"><a href="#val-rindex" class="anchor"></a><code><span><span class="keyword">val</span> rindex : <span>bytes <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>rindex s c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code>.</p><p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_opt" class="anchored"><a href="#val-rindex_opt" class="anchor"></a><code><span><span class="keyword">val</span> rindex_opt : <span>bytes <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>rindex_opt s c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-index_from" class="anchored"><a href="#val-index_from" class="anchor"></a><code><span><span class="keyword">val</span> index_from : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>index_from s i c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code> after position <code>i</code>. <code>Bytes.index s c</code> is equivalent to <code>Bytes.index_from s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-index_from_opt" class="anchored"><a href="#val-index_from_opt" class="anchor"></a><code><span><span class="keyword">val</span> index_from_opt : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index_from _opts i c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code> after position <code>i</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>. <code>Bytes.index_opt s c</code> is equivalent to <code>Bytes.index_from_opt s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_from" class="anchored"><a href="#val-rindex_from" class="anchor"></a><code><span><span class="keyword">val</span> rindex_from : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>rindex_from s i c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code> before position <code>i+1</code>. <code>rindex s c</code> is equivalent to <code>rindex_from s (Bytes.length s - 1) c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_from_opt" class="anchored"><a href="#val-rindex_from_opt" class="anchor"></a><code><span><span class="keyword">val</span> rindex_from_opt : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>rindex_from_opt s i c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code> before position <code>i+1</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>. <code>rindex_opt s c</code> is equivalent to <code>rindex_from s (Bytes.length s - 1) c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-contains" class="anchored"><a href="#val-contains" class="anchor"></a><code><span><span class="keyword">val</span> contains : <span>bytes <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>contains s c</code> tests if byte <code>c</code> appears in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-contains_from" class="anchored"><a href="#val-contains_from" class="anchor"></a><code><span><span class="keyword">val</span> contains_from : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>contains_from s start c</code> tests if byte <code>c</code> appears in <code>s</code> after position <code>start</code>. <code>contains s c</code> is equivalent to <code>contains_from
    s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> is not a valid position in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rcontains_from" class="anchored"><a href="#val-rcontains_from" class="anchor"></a><code><span><span class="keyword">val</span> rcontains_from : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>char <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>rcontains_from s stop c</code> tests if byte <code>c</code> appears in <code>s</code> before position <code>stop+1</code>.</p><p>Raise <code>Invalid_argument</code> if <code>stop &lt; 0</code> or <code>stop+1</code> is not a valid position in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uppercase" class="anchored"><a href="#val-uppercase" class="anchor"></a><code><span><span class="keyword">val</span> uppercase : <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-lowercase" class="anchored"><a href="#val-lowercase" class="anchor"></a><code><span><span class="keyword">val</span> lowercase : <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-capitalize" class="anchored"><a href="#val-capitalize" class="anchor"></a><code><span><span class="keyword">val</span> capitalize : <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with the first character set to uppercase, using the ISO Latin-1 (8859-1) character set..</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-uncapitalize" class="anchored"><a href="#val-uncapitalize" class="anchor"></a><code><span><span class="keyword">val</span> uncapitalize : <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with the first character set to lowercase, using the ISO Latin-1 (8859-1) character set..</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-uppercase_ascii" class="anchored"><a href="#val-uppercase_ascii" class="anchor"></a><code><span><span class="keyword">val</span> uppercase_ascii : <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with all lowercase letters translated to uppercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-lowercase_ascii" class="anchored"><a href="#val-lowercase_ascii" class="anchor"></a><code><span><span class="keyword">val</span> lowercase_ascii : <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with all uppercase letters translated to lowercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-capitalize_ascii" class="anchored"><a href="#val-capitalize_ascii" class="anchor"></a><code><span><span class="keyword">val</span> capitalize_ascii : <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with the first character set to uppercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-uncapitalize_ascii" class="anchored"><a href="#val-uncapitalize_ascii" class="anchor"></a><code><span><span class="keyword">val</span> uncapitalize_ascii : <span>bytes <span>&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with the first character set to lowercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = bytes</span></code></div><div class="spec-doc"><p>An alias for the type of byte sequences.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span>&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The comparison function for byte sequences, with the same specification as <a href="../index.html#val-compare"><code>Stdlib.compare</code></a>. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>Bytes</code> to be passed as argument to the functors <code>Set</code>.Make and <code>Map</code>.Make.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span>&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span>&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>The equality function for byte sequences.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></div></div><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2><div class="odoc-spec"><div class="spec value" id="val-to_seq" class="anchored"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><a href="#type-t">t</a> <span>&#45;&gt;</span></span> <span>char <a href="../../../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the string, in increasing index order. Modifications of the string during iteration will be reflected in the iterator.</p><dl><dt>since</dt><dd>4.07</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-to_seqi" class="anchored"><a href="#val-to_seqi" class="anchor"></a><code><span><span class="keyword">val</span> to_seqi : <span><a href="#type-t">t</a> <span>&#45;&gt;</span></span> <span><span>(int * char)</span> <a href="../../../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the string, in increasing order, yielding indices along chars</p><dl><dt>since</dt><dd>4.07</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq" class="anchored"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span>char <a href="../../../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span> <span>&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a string from the generator</p><dl><dt>since</dt><dd>4.07</dd></dl></div></div><h2 id="binary-encoding/decoding-of-integers"><a href="#binary-encoding/decoding-of-integers" class="anchor"></a>Binary encoding/decoding of integers</h2><p>The functions in this section binary encode and decode integers to and from byte sequences.</p><p>All following functions raise <code>Invalid_argument</code> if the space needed at index <code>i</code> to decode or encode the integer is not available.</p><p>Little-endian (resp. big-endian) encoding means that least (resp. most) significant bytes are stored first. Big-endian is also known as network byte order. Native-endian encoding is either little-endian or big-endian depending on <code>Sys</code>.big_endian.</p><p>32-bit and 64-bit integers are represented by the <code>int32</code> and <code>int64</code> types, which can be interpreted either as signed or unsigned numbers.</p><p>8-bit and 16-bit integers are represented by the <code>int</code> type, which has more bits than the binary encoding. These extra bits are handled as follows: </p><ul><li>Functions that decode signed (resp. unsigned) 8-bit or 16-bit integers represented by <code>int</code> values sign-extend (resp. zero-extend) their result.</li><li>Functions that encode 8-bit or 16-bit integers represented by <code>int</code> values truncate their input to their least significant bytes.</li></ul><div class="odoc-spec"><div class="spec value" id="val-get_uint8" class="anchored"><a href="#val-get_uint8" class="anchor"></a><code><span><span class="keyword">val</span> get_uint8 : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_uint8 b i</code> is <code>b</code>'s unsigned 8-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int8" class="anchored"><a href="#val-get_int8" class="anchor"></a><code><span><span class="keyword">val</span> get_int8 : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int8 b i</code> is <code>b</code>'s signed 8-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-get_uint16_ne" class="anchored"><a href="#val-get_uint16_ne" class="anchor"></a><code><span><span class="keyword">val</span> get_uint16_ne : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_uint16_ne b i</code> is <code>b</code>'s native-endian unsigned 16-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-get_uint16_be" class="anchored"><a href="#val-get_uint16_be" class="anchor"></a><code><span><span class="keyword">val</span> get_uint16_be : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_uint16_be b i</code> is <code>b</code>'s big-endian unsigned 16-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-get_uint16_le" class="anchored"><a href="#val-get_uint16_le" class="anchor"></a><code><span><span class="keyword">val</span> get_uint16_le : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_uint16_le b i</code> is <code>b</code>'s little-endian unsigned 16-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int16_ne" class="anchored"><a href="#val-get_int16_ne" class="anchor"></a><code><span><span class="keyword">val</span> get_int16_ne : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int16_ne b i</code> is <code>b</code>'s native-endian signed 16-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int16_be" class="anchored"><a href="#val-get_int16_be" class="anchor"></a><code><span><span class="keyword">val</span> get_int16_be : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int16_be b i</code> is <code>b</code>'s big-endian signed 16-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int16_le" class="anchored"><a href="#val-get_int16_le" class="anchor"></a><code><span><span class="keyword">val</span> get_int16_le : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int16_le b i</code> is <code>b</code>'s little-endian signed 16-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int32_ne" class="anchored"><a href="#val-get_int32_ne" class="anchor"></a><code><span><span class="keyword">val</span> get_int32_ne : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int32</span></code></div><div class="spec-doc"><p><code>get_int32_ne b i</code> is <code>b</code>'s native-endian 32-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int32_be" class="anchored"><a href="#val-get_int32_be" class="anchor"></a><code><span><span class="keyword">val</span> get_int32_be : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int32</span></code></div><div class="spec-doc"><p><code>get_int32_be b i</code> is <code>b</code>'s big-endian 32-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int32_le" class="anchored"><a href="#val-get_int32_le" class="anchor"></a><code><span><span class="keyword">val</span> get_int32_le : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int32</span></code></div><div class="spec-doc"><p><code>get_int32_le b i</code> is <code>b</code>'s little-endian 32-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int64_ne" class="anchored"><a href="#val-get_int64_ne" class="anchor"></a><code><span><span class="keyword">val</span> get_int64_ne : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>get_int64_ne b i</code> is <code>b</code>'s native-endian 64-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int64_be" class="anchored"><a href="#val-get_int64_be" class="anchor"></a><code><span><span class="keyword">val</span> get_int64_be : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>get_int64_be b i</code> is <code>b</code>'s big-endian 64-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int64_le" class="anchored"><a href="#val-get_int64_le" class="anchor"></a><code><span><span class="keyword">val</span> get_int64_le : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>get_int64_le b i</code> is <code>b</code>'s little-endian 64-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_uint8" class="anchored"><a href="#val-set_uint8" class="anchor"></a><code><span><span class="keyword">val</span> set_uint8 : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_uint8 b i v</code> sets <code>b</code>'s unsigned 8-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int8" class="anchored"><a href="#val-set_int8" class="anchor"></a><code><span><span class="keyword">val</span> set_int8 : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int8 b i v</code> sets <code>b</code>'s signed 8-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_uint16_ne" class="anchored"><a href="#val-set_uint16_ne" class="anchor"></a><code><span><span class="keyword">val</span> set_uint16_ne : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_uint16_ne b i v</code> sets <code>b</code>'s native-endian unsigned 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_uint16_be" class="anchored"><a href="#val-set_uint16_be" class="anchor"></a><code><span><span class="keyword">val</span> set_uint16_be : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_uint16_be b i v</code> sets <code>b</code>'s big-endian unsigned 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_uint16_le" class="anchored"><a href="#val-set_uint16_le" class="anchor"></a><code><span><span class="keyword">val</span> set_uint16_le : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_uint16_le b i v</code> sets <code>b</code>'s little-endian unsigned 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int16_ne" class="anchored"><a href="#val-set_int16_ne" class="anchor"></a><code><span><span class="keyword">val</span> set_int16_ne : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int16_ne b i v</code> sets <code>b</code>'s native-endian signed 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int16_be" class="anchored"><a href="#val-set_int16_be" class="anchor"></a><code><span><span class="keyword">val</span> set_int16_be : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int16_be b i v</code> sets <code>b</code>'s big-endian signed 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int16_le" class="anchored"><a href="#val-set_int16_le" class="anchor"></a><code><span><span class="keyword">val</span> set_int16_le : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int16_le b i v</code> sets <code>b</code>'s little-endian signed 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int32_ne" class="anchored"><a href="#val-set_int32_ne" class="anchor"></a><code><span><span class="keyword">val</span> set_int32_ne : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int32 <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int32_ne b i v</code> sets <code>b</code>'s native-endian 32-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int32_be" class="anchored"><a href="#val-set_int32_be" class="anchor"></a><code><span><span class="keyword">val</span> set_int32_be : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int32 <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int32_be b i v</code> sets <code>b</code>'s big-endian 32-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int32_le" class="anchored"><a href="#val-set_int32_le" class="anchor"></a><code><span><span class="keyword">val</span> set_int32_le : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int32 <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int32_le b i v</code> sets <code>b</code>'s little-endian 32-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int64_ne" class="anchored"><a href="#val-set_int64_ne" class="anchor"></a><code><span><span class="keyword">val</span> set_int64_ne : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int64 <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int64_ne b i v</code> sets <code>b</code>'s native-endian 64-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int64_be" class="anchored"><a href="#val-set_int64_be" class="anchor"></a><code><span><span class="keyword">val</span> set_int64_be : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int64 <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int64_be b i v</code> sets <code>b</code>'s big-endian 64-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int64_le" class="anchored"><a href="#val-set_int64_le" class="anchor"></a><code><span><span class="keyword">val</span> set_int64_le : <span>bytes <span>&#45;&gt;</span></span> <span>int <span>&#45;&gt;</span></span> <span>int64 <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int64_le b i v</code> sets <code>b</code>'s little-endian 64-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></div></div></details></div></div></div><div class="odoc-spec"><div class="spec value" id="val-sub_string" class="anchored"><a href="#val-sub_string" class="anchor"></a><code><span><span class="keyword">val</span> sub_string : <span>bytes <span>&#45;&gt;</span></span> <span>pos:int <span>&#45;&gt;</span></span> <span>len:int <span>&#45;&gt;</span></span> string</span></code></div></div></div></body></html>