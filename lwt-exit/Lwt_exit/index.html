<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lwt_exit (lwt-exit.Lwt_exit)</title><link rel="stylesheet" href="../../odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0-beta2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">lwt-exit</a> &#x00BB; Lwt_exit</nav><header class="odoc-preamble"><h1>Module <code><span>Lwt_exit</span></code></h1><h2 id="lwt_exit"><a href="#lwt_exit" class="anchor"></a><code>Lwt_exit</code></h2><p><code>Lwt_exit</code> provides helpers to handle:</p><ul><li>OS signals,</li><li>cleaning-up before exiting, and</li><li>exiting.</li></ul><p>Specifically, this module allows users to (1) register clean-up callbacks and (2) trigger a soft exit. When a soft exit is triggered, the clean-up callbacks are called. The process exits once all the clean-up callbacks calls have resolved.</p></header><nav class="odoc-toc"><ul><li><a href="#state">State</a></li><li><a href="#clean-up-callbacks">Clean-up callbacks</a></li><li><a href="#exiting">Exiting</a></li><li><a href="#signal-management">Signal management</a></li><li><a href="#main-promise-wrappers">Main promise wrappers</a></li><li><a href="#misc-recommendations">Misc recommendations</a><ul><li><a href="#one-shot">One-shot</a></li><li><a href="#registering-callbacks">Registering callbacks</a></li><li><a href="#registering,-unregistering,-and-loops">Registering, unregistering, and loops</a></li><li><a href="#cleanly-interrupting-a-main-loop">Cleanly interrupting a main loop</a></li></ul></li></ul></nav><div class="odoc-content"><h3 id="state"><a href="#state" class="anchor"></a>State</h3><div class="odoc-spec"><div class="spec value" id="val-clean_up_starts" class="anchored"><a href="#val-clean_up_starts" class="anchor"></a><code><span><span class="keyword">val</span> clean_up_starts : <span>int <a href="../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>A global promise that resolves when clean-up starts. Note that there is no way to &quot;just&quot; start clean-up. Specifically, it is only possible to start the clean-up as a side-effect of triggering an exit.</p><p>It is safe to use <code>clean_up_starts</code>, even in the &quot;main&quot; promise. See example below in <code>Misc recommendations</code>-<code>Cleanly interrupting a main loop</code>. It is safe because <code>Lwt_exit</code> always witnesses the resolution of this promise before users of the library.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-clean_up_ends" class="anchored"><a href="#val-clean_up_ends" class="anchor"></a><code><span><span class="keyword">val</span> clean_up_ends : <span>int <a href="../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>A global promise that resolves when clean-up ends.</p></div></div><h3 id="clean-up-callbacks"><a href="#clean-up-callbacks" class="anchor"></a>Clean-up callbacks</h3><p>Attaching and detaching callbacks.</p><div class="odoc-spec"><div class="spec type" id="type-clean_up_callback_id" class="anchored"><a href="#type-clean_up_callback_id" class="anchor"></a><code><span><span class="keyword">type</span> clean_up_callback_id</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-register_clean_up_callback" class="anchored"><a href="#val-register_clean_up_callback" class="anchor"></a><code><span><span class="keyword">val</span> register_clean_up_callback : <span>?&#8288;after:<span><a href="#type-clean_up_callback_id">clean_up_callback_id</a> list</span> <span>&#45;&gt;</span></span> <span>loc:string <span>&#45;&gt;</span></span> <span><span>(<span>int <span>&#45;&gt;</span></span> <span>unit <a href="../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span></span> <a href="#type-clean_up_callback_id">clean_up_callback_id</a></span></code></div><div class="spec-doc"><p><code>register_clean_up_callback f</code> registers <code>f</code> to be called as part of the clean-up. Typically this is used to flush outputs, rollback/commit pending changes, gracefully close connections with peers, etc.</p><p>The call to <code>f</code> receives an argument <code>n</code> that indicates the status the process will exit with at the end of clean-up: <code>0</code> is for success, <code>127</code> for interruption by signals, <code>126</code> for uncaught exceptions, other values are available for the application's own exit codes.</p><p>The argument <code>after</code>, if passed, delays the call to this clean-up callback until the clean-up callbacks identified by <code>after</code> have resolved. Apart from this synchronization mechanism, all clean-up callbacks execute eagerly and concurrently. Note that more complex synchronization is discouraged but possible via standard Lwt techniques.</p><p>Note that if one of the callbacks identified in <code>after</code> is unregistered (through <a href="#val-unregister_clean_up_callback"><code>unregister_clean_up_callback</code></a>) then it is simply ignored for the purpose of synchronization. Thus, it is important to indicate all the &quot;dependencies&quot; of a clean-up callback and not rely on transitive &quot;dependencies&quot;.</p><p>Once clean-up has started, this function has no effect.</p><p>The promise returned by this callback may be canceled if it takes too long to complete. (See <code>max_clean_up_time</code> below.)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unregister_clean_up_callback" class="anchored"><a href="#val-unregister_clean_up_callback" class="anchor"></a><code><span><span class="keyword">val</span> unregister_clean_up_callback : <span><a href="#type-clean_up_callback_id">clean_up_callback_id</a> <span>&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unregister_clean_up_callback cid</code> removes the callback with id <code>cid</code> from the set of functions to call for cleaning up.</p><p>Once clean-up has started, this function has no effect.</p></div></div><p>Example use:</p><pre><code>let p = open_resource r in
let clean_p = register_clean_up_callback (fun _ -&gt; close_resource p) in
let rec feed () =
   read () &gt;&gt;= fun v -&gt;
   push_to_resource p &gt;&gt;= fun () -&gt;
   feed ()
in
feed () &gt;&gt;= fun () -&gt;
close_resource p &gt;&gt;= fun () -&gt;
unregister_clean_up_callback clean_p;
Lwt.return ()</code></pre><h3 id="exiting"><a href="#exiting" class="anchor"></a>Exiting</h3><div class="odoc-spec"><div class="spec value" id="val-exit_and_raise" class="anchored"><a href="#val-exit_and_raise" class="anchor"></a><code><span><span class="keyword">val</span> exit_and_raise : <span>int <span>&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>exit_and_raise n</code> triggers a soft exit (including clean-up) and raises <a href="../../ocaml/Stdlib/index.html#exception-Exit"><code>Stdlib.Exit</code></a>. This is intended for use deep inside the program, at a place that wants to trigger an exit after observing, say, a fatal error.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exit_and_wait" class="anchored"><a href="#val-exit_and_wait" class="anchor"></a><code><span><span class="keyword">val</span> exit_and_wait : <span>int <span>&#45;&gt;</span></span> <span>int <a href="../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>exit_and_wait n</code> triggers a soft exit (including clean-up) and stays pending until it is finished. This is intended to be used directly within <code>Lwt_main</code>.run for a clean exit.</p></div></div><h3 id="signal-management"><a href="#signal-management" class="anchor"></a>Signal management</h3><p>A soft signal handler is one that triggers clean-up.</p><p>After the clean-up has started, and after a safety period has elapsed, sending the same soft-handled signal a second time terminates the process immediately. The safety period is set by the parameter <code>double_signal_safety</code> of the <a href="#val-wrap_and_exit"><code>wrap_and_exit</code></a>, <a href="#val-wrap_and_error"><code>wrap_and_error</code></a>, and <a href="#val-wrap_and_forward"><code>wrap_and_forward</code></a> functions (below).</p><p>A hard signal handler is one that terminates the process immediately.</p><p>IMPORTANT: a hard exit can leave open files in inconsistent states.</p><div class="odoc-spec"><div class="spec type" id="type-signal_setup" class="anchored"><a href="#type-signal_setup" class="anchor"></a><code><span><span class="keyword">type</span> signal_setup</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-make_signal_setup" class="anchored"><a href="#val-make_signal_setup" class="anchor"></a><code><span><span class="keyword">val</span> make_signal_setup : <span>soft:<span>int list</span> <span>&#45;&gt;</span></span> <span>hard:<span>int list</span> <span>&#45;&gt;</span></span> <a href="#type-signal_setup">signal_setup</a></span></code></div><div class="spec-doc"><p><code>make_signal_setup ~soft ~hard</code> is a signal setup with <code>soft</code> as soft signals and <code>hard</code> as hard signals.</p><dl><dt>raises {!Stdlib.Invalid_argument}</dt><dd><p>if a signal is not one declared in <code>Sys</code> (see all <code>Sys.sig*</code> values).</p></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-default_signal_setup" class="anchored"><a href="#val-default_signal_setup" class="anchor"></a><code><span><span class="keyword">val</span> default_signal_setup : <a href="#type-signal_setup">signal_setup</a></span></code></div><div class="spec-doc"><p><code>default_signal_setup</code> is <code>make_signal_setup ~soft:[Sys.sigint; Sys.sigterm] ~hard:[]</code>.</p><p>Note that pressing Ctrl-C sends <code>SIGINT</code> to the process whilst shutting it down through systemd sends <code>SIGTERM</code>. This is the reasoning behind the default: both of those signals should be handled softly in most cases.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-signal_name" class="anchored"><a href="#val-signal_name" class="anchor"></a><code><span><span class="keyword">val</span> signal_name : <span>int <span>&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>signal_name signal</code> is the name of <code>signal</code>. E.g., <code>signal_name Sys.sigterm</code> is <code>&quot;TERM&quot;</code>.</p></div></div><h3 id="main-promise-wrappers"><a href="#main-promise-wrappers" class="anchor"></a>Main promise wrappers</h3><div class="odoc-spec"><div class="spec value" id="val-wrap_and_exit" class="anchored"><a href="#val-wrap_and_exit" class="anchor"></a><code><span><span class="keyword">val</span> wrap_and_exit : <span>?&#8288;signal_setup:<a href="#type-signal_setup">signal_setup</a> <span>&#45;&gt;</span></span> <span>?&#8288;double_signal_safety:<a href="../../ptime/Ptime/Span/index.html#type-t">Ptime.Span.t</a> <span>&#45;&gt;</span></span>
<span>?&#8288;max_clean_up_time:<a href="../../ptime/Ptime/Span/index.html#type-t">Ptime.Span.t</a> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../lwt/Lwt/index.html#type-t">Lwt.t</a></span> <span>&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>wrap_and_exit p</code> is a promise <code>q</code> that behaves as follows:</p><p>NORMAL OPERATION:</p><p>If <code>p</code> is fulfilled with value <code>v</code> (and <code>exit_and_raise</code> was not called) then</p><ul><li><code>q</code> also is fulfilled with <code>v</code>. The process does not exit.</li></ul><p>If <code>exit_and_raise code</code> is called before <code>p</code> is resolved, then</p><ul><li>the clean-up starts,</li><li><code>p</code> is canceled,</li><li>the process terminates as soon as clean-up ends with exit code <code>code</code>.</li></ul><p>If <code>p</code> is rejected (and <code>exit_and_raise</code> was not called), it is equivalent to calling <code>exit_and_raise 126</code>. I.e.,</p><ul><li>the clean-up starts,</li><li>the process terminates as soon as clean-up ends with exit code <code>126</code>.</li></ul><p>EXIT CODE:</p><p>The exit code of the process is masked with <code>lor 128</code> (i.e., setting the 8th bit) if the clean-up did not complete successfully (i.e., if any of the clean-up callbacks were rejected).</p><p>E.g., if you call <code>exit_and_raise 1</code> and one of the clean-up callback fails (is rejected with an exception), then the exit code is <code>1 lor 128 = 129</code>.</p><p>Note that even if one clean-up callback fails, the other clean-up callbacks are left to execute.</p><p>SIGNALS:</p><p>In addition, <code>wrap_and_exit p</code> sets up the signal handlers described above (see <a href="#type-signal_setup"><code>signal_setup</code></a>).</p><p>Any hard-signal that is received triggers an immediate process termination with exit code <code>127 lor 128 = 255</code>.</p><p>Any soft-signal that is received triggers a call to <code>exit_and_raise 127</code> (the consequences of which are described above).</p><p>Note that if the same soft-signal is sent a second-time, the process terminates immediately with code <code>127 lor 128 = 255</code>.</p><p>To summarize, the exit code can be thought of as a 8-bit integer with the following properties:</p><ul><li>the highest bit is set if the clean-up was unsuccessful/incomplete</li><li>the second highest bit is set if the process exited because of a signal</li><li>the third highest bit is set if the process exited because of an uncaught exception</li><li>all other bits can be used by the application as wanted.</li></ul><p>Note that if the second (signal) or third (exception) highest bits are set, then only the highest (incomplete clean-up) may also be set.</p><p>EXCEPTIONS:</p><dl><dt>raises {!Invalid_argument}</dt><dd><p>if called after clean-up has already started. See <code>Misc recommendations</code> below for details about the consequences of this.</p><p>OPTIONAL PARAMETERS:</p><p>The optional argument <code>max_clean_up_time</code> limits the time the clean-up phase is allowed to run for. If any of the clean-up callbacks is still pending when <code>max_clean_up_time</code> has elapsed, the process exits immediately. If the clean-up is interrupted by this then the exit code is masked with <code>128</code> as described above.</p><p>By default <code>max_clean_up_time</code> is not set and no limits is set for the completion of the clean-up callbacks.</p><p>The optional argument <code>double_signal_safety</code> (defaults to one (1) second) is the grace period after sending one of the softly-handled signal before sending the same signal is handled as hard.</p><p>This is meant to protect against double-pressing Ctrl-C in an interactive terminal session. If you press Ctrl-c once, a soft exit is triggered, if you press it again (accidentally) within the grace period it is ignored, if you press it again after the grace period has elapsed it is treated as a hard exit.</p><p>The optional argument <code>signal_setup</code> (defaults to <code>default_signal_setup</code>) sets up soft and hard handlers at the beginning and clears them when <code>q</code> resolves.</p><p>EXAMPLE:</p><p>Intended use:</p><pre><code>Stdlib.exit @@ Lwt_main.run begin
   Lwt_exit.wrap_and_exit (init ()) &gt;&gt;= fun v -&gt;
   let ccbid_v = register_clean_up_callback ~loc:__LOC__ (fun _ -&gt; clean v) in
   Lwt_exit.wrap_and_exit (main v) &gt;&gt;= fun r -&gt;
   let () = unregister_clean_up_callback ccbid_v in
   let ccbid_r = register_clean_up_callback ~loc:__LOC__ (fun _ -&gt; free r) in
   Lwt_exit.wrap_and_exit (shutdown v) &gt;&gt;= fun () -&gt;
   exit_and_wait 0 (* clean exit afterwards *)
end</code></pre></dd></dl></div></div><div class="odoc-spec"><div class="spec value" id="val-wrap_and_error" class="anchored"><a href="#val-wrap_and_error" class="anchor"></a><code><span><span class="keyword">val</span> wrap_and_error : <span>?&#8288;signal_setup:<a href="#type-signal_setup">signal_setup</a> <span>&#45;&gt;</span></span> <span>?&#8288;double_signal_safety:<a href="../../ptime/Ptime/Span/index.html#type-t">Ptime.Span.t</a> <span>&#45;&gt;</span></span>
<span>?&#8288;max_clean_up_time:<a href="../../ptime/Ptime/Span/index.html#type-t">Ptime.Span.t</a> <span>&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../lwt/Lwt/index.html#type-t">Lwt.t</a></span> <span>&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, int)</span> <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>wrap_and_error p</code> is similar to <a href="#val-wrap_and_exit"><code>wrap_and_exit</code></a> <code>p</code> but it resolves to <code>Error status</code> instead of exiting with <code>status</code>. When it resolves with <code>Error _</code> (i.e., if a soft-exit has been triggered), clean-up has already ended.</p><p>Intended use:</p><pre><code>Stdlib.exit @@ Lwt_main.run begin
   Lwt_exit.wrap_and_error (init ()) &gt;&gt;= function
   | Error exit_status -&gt;
      Format.eprintf &quot;Initialisation failed\n%!&quot;;
      Lwt.return exit_status
   | Ok v -&gt;
      Lwt_exit.wrap_and_error (main v) &gt;&gt;= function
      | Error exit_status -&gt;
         Format.eprintf &quot;Processing failed\n%!&quot;;
         Lwt.return exit_status
      | Ok v -&gt;
         Lwt_exit.wrap_and_error (shutdown ()) &gt;&gt;= function
         | Error exit_status -&gt;
            Format.eprintf &quot;Shutdown failed\n%!&quot;;
            Lwt.return exit_status
         | Ok () -&gt;
            exit_and_wait 0 &gt;&gt;= fun _ -&gt;
            Lwt.return 0
end</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-wrap_and_forward" class="anchored"><a href="#val-wrap_and_forward" class="anchor"></a><code><span><span class="keyword">val</span> wrap_and_forward : <span>?&#8288;signal_setup:<a href="#type-signal_setup">signal_setup</a> <span>&#45;&gt;</span></span> <span>?&#8288;double_signal_safety:<a href="../../ptime/Ptime/Span/index.html#type-t">Ptime.Span.t</a> <span>&#45;&gt;</span></span>
<span>?&#8288;max_clean_up_time:<a href="../../ptime/Ptime/Span/index.html#type-t">Ptime.Span.t</a> <span>&#45;&gt;</span></span> <span><span>int <a href="../../lwt/Lwt/index.html#type-t">Lwt.t</a></span> <span>&#45;&gt;</span></span> <span>int <a href="../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>wrap_and_forward p</code> is similar to <a href="#val-wrap_and_error"><code>wrap_and_error</code></a> <code>p</code> except that it collapses <code>Ok _</code> and <code>Error _</code>.</p><p>Note that, in general, you can expect the status <code>0</code> to come from a successfully resolved <code>p</code>. However, It could also be because of a soft-exit with status <code>0</code>. As a result, you cannot be certain, based on the status alone, whether clean-up callbacks have been called.</p><p>Intended use:</p><pre><code>Stdlib.exit @@ Lwt_main.run begin
   Lwt_exit.wrap_and_forward (main ()) &gt;&gt;= function
   | 0 -&gt;
      Format.printf &quot;I'm done, bye!\n%!&quot;;
      Lwt.return 0
   | 127 -&gt; (* signaling *)
      Format.printf &quot;Shutdown complete\n&quot;;
      Lwt.return 1
   | 126 -&gt; (* uncaught exception *)
      Format.printf &quot;An error occurred.\n&quot;;
      Format.printf &quot;Please check %s\n&quot; log_file;
      Format.printf &quot;And consider reporting the issue\n%!&quot;;
      Lwt.return 2
   | _ -&gt; assert false
end</code></pre></div></div><h3 id="misc-recommendations"><a href="#misc-recommendations" class="anchor"></a>Misc recommendations</h3><h4 id="one-shot"><a href="#one-shot" class="anchor"></a>One-shot</h4><p><code>Lwt_exit</code> is one-shot: once the clean-up has started, further uses of <code>wrap_and_*</code> will raise <code>Invalid_argument</code>.</p><p>Note, for example, how in the <a href="#val-wrap_and_error"><code>wrap_and_error</code></a> example, <code>wrap_and_error</code> is called multiple time, but on <code>Ok</code> branches where clean-up has <em>not</em> happened. This is ok.</p><p>On the other hand, using <code>wrap_and_error</code> in an <code>Error</code> branch would be unsound because clean-up has happened in these branches.</p><h4 id="registering-callbacks"><a href="#registering-callbacks" class="anchor"></a>Registering callbacks</h4><p>To the extent that it is possible, you should register your clean-up callbacks as soon as a resource that needs clean-up is allocated.</p><pre><code>let r = &lt;resource initialization&gt; in
let c = register_clean_up_callback ~loc:__LOC__ (fun s -&gt; &lt;clean-up code&gt;) in
&lt;resource use&gt;;
let () = unregister_clean_up_callback c in
&lt;normal clean-up code&gt;;
&lt;continue&gt;</code></pre><p>When possible, you can even register the callback before-hand.</p><pre><code>let rr = ref None in
let c = register_clean_up_callback
   ~loc:__LOC__
   (fun s -&gt; Option.iter (fun r -&gt; &lt;clean-up code&gt;) !rr)
in
let rr := Some &lt;resource initialization&gt; in
&lt;resource use&gt;;
let () = unregister_clean_up_callback c in
rr := None;
&lt;normal clean-up code&gt;;
&lt;continue&gt;</code></pre><h4 id="registering,-unregistering,-and-loops"><a href="#registering,-unregistering,-and-loops" class="anchor"></a>Registering, unregistering, and loops</h4><p>In a tight-loop, in the event loop of an actor, etc. avoid registering and unregistering clean-up callbacks repeatedly. Instead, you should create an intermediate layer dedicated to clean-up. E.g.,</p><pre><code>let module Resources = Set.Make(&lt;resource OrderedType module&gt;) in
let rs = ref Resources.empty in
let c = register_clean_up_callback
   ~loc:__LOC__
   (fun s -&gt; Resources.iter
      (fun r -&gt; &lt;resource clean-up&gt;; Lwt.return ())
      !rs)
in
let rec loop () =
   receive () &gt;&gt;= function
   | End -&gt; Lwt.return ()
   | Input input -&gt;
      let _process =
         let r = &lt;resource initialization&gt; in
         rs := Resources.add r !rs;
         &lt;resource use (use input)&gt; &gt;&gt;= fun () -&gt;
         rs := Resources.remove r !rs;
         &lt;normal clean-up&gt;;
         Lwt.return ()
      in
      loop ()
in
loop ()</code></pre><p>Note that this is a general example and your specific use would differ.</p><p>More importantly, note that in this specific case we do not unregister the clean-up callback because there is no point at which we know that the resource set is empty. It's ok because the clean-up will be a very fast no-op. Coming up with a solution that allows unregistering of the clean-up callback is left as an exercise to the reader.</p><h4 id="cleanly-interrupting-a-main-loop"><a href="#cleanly-interrupting-a-main-loop" class="anchor"></a>Cleanly interrupting a main loop</h4><p>In a program that does not normally exit, you might want to interrupt the main loop (to avoid further processing) as soon as clean-up has started (either because a signal was received or because a fatal exception deep within the program was handled by calling <a href="#val-exit_and_raise"><code>exit_and_raise</code></a>).</p><p>This is easily achieved by passing the main-loop to <code>wrap_and_*</code>. As mentioned in the documentation of <a href="#val-wrap_and_exit"><code>wrap_and_exit</code></a>, the promise passed as argument is cancelled as soon as the clean-up starts.</p><p>However, there may be other loops that are not syntactically available to the main wrapper. In this case, the simple pattern below is safe and the loop, provided it is cancelable, will stop when the clean-up starts.</p><pre><code>let rec loop () =
   get_task () &gt;&gt;= fun task -&gt;
   process task &gt;&gt;= fun () -&gt;
   loop ()
in
Lwt.pick [loop (); Lwt_exit.clean_up_starts]</code></pre><p>Arguably, for such a simple case, you can replace the pattern above by a simple clean-up callback that cancels the loop. However, for more complex arrangements, the <code>pick</code>-with-<code>clean_up_starts</code> pattern above can be useful.</p></div></body></html>